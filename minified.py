exec('import ctypes\nimport ctypes.wintypes as wintypes\nimport threading\nimport collections\nimport os\nimport uuid\nimport struct\nimport codecs\nimport time\nimport math\nimport string\nimport mmap\n\nfrom collections import Counter\nfrom hashlib import sha1\nfrom hashlib import sha256\nfrom hashlib import sha512\nfrom hashlib import md5\n\nimport functools\nimport copy as copymod\n\n\n"""\n\n######################################################################################           ######################################################################################\n###################################################################################### PEFILE.PY ######################################################################################\n######################################################################################           ######################################################################################\n\n"""\n\noleaut32_ord_names={2:b\'SysAllocString\',3:b\'SysReAllocString\',4:b\'SysAllocStringLen\',5:b\'SysReAllocStringLen\',6:b\'SysFreeString\',7:b\'SysStringLen\',8:b\'VariantInit\',9:b\'VariantClear\',10:b\'VariantCopy\',11:b\'VariantCopyInd\',12:b\'VariantChangeType\',13:b\'VariantTimeToDosDateTime\',14:b\'DosDateTimeToVariantTime\',15:b\'SafeArrayCreate\',16:b\'SafeArrayDestroy\',17:b\'SafeArrayGetDim\',18:b\'SafeArrayGetElemsize\',19:b\'SafeArrayGetUBound\',20:b\'SafeArrayGetLBound\',21:b\'SafeArrayLock\',22:b\'SafeArrayUnlock\',23:b\'SafeArrayAccessData\',24:b\'SafeArrayUnaccessData\',25:b\'SafeArrayGetElement\',26:b\'SafeArrayPutElement\',27:b\'SafeArrayCopy\',28:b\'DispGetParam\',29:b\'DispGetIDsOfNames\',30:b\'DispInvoke\',31:b\'CreateDispTypeInfo\',32:b\'CreateStdDispatch\',33:b\'RegisterActiveObject\',34:b\'RevokeActiveObject\',35:b\'GetActiveObject\',36:b\'SafeArrayAllocDescriptor\',37:b\'SafeArrayAllocData\',38:b\'SafeArrayDestroyDescriptor\',39:b\'SafeArrayDestroyData\',40:b\'SafeArrayRedim\',41:b\'SafeArrayAllocDescriptorEx\',42:b\'SafeArrayCreateEx\',43:b\'SafeArrayCreateVectorEx\',44:b\'SafeArraySetRecordInfo\',45:b\'SafeArrayGetRecordInfo\',46:b\'VarParseNumFromStr\',47:b\'VarNumFromParseNum\',48:b\'VarI2FromUI1\',49:b\'VarI2FromI4\',50:b\'VarI2FromR4\',51:b\'VarI2FromR8\',52:b\'VarI2FromCy\',53:b\'VarI2FromDate\',54:b\'VarI2FromStr\',55:b\'VarI2FromDisp\',56:b\'VarI2FromBool\',57:b\'SafeArraySetIID\',58:b\'VarI4FromUI1\',59:b\'VarI4FromI2\',60:b\'VarI4FromR4\',61:b\'VarI4FromR8\',62:b\'VarI4FromCy\',63:b\'VarI4FromDate\',64:b\'VarI4FromStr\',65:b\'VarI4FromDisp\',66:b\'VarI4FromBool\',67:b\'SafeArrayGetIID\',68:b\'VarR4FromUI1\',69:b\'VarR4FromI2\',70:b\'VarR4FromI4\',71:b\'VarR4FromR8\',72:b\'VarR4FromCy\',73:b\'VarR4FromDate\',74:b\'VarR4FromStr\',75:b\'VarR4FromDisp\',76:b\'VarR4FromBool\',77:b\'SafeArrayGetVartype\',78:b\'VarR8FromUI1\',79:b\'VarR8FromI2\',80:b\'VarR8FromI4\',81:b\'VarR8FromR4\',82:b\'VarR8FromCy\',83:b\'VarR8FromDate\',84:b\'VarR8FromStr\',85:b\'VarR8FromDisp\',86:b\'VarR8FromBool\',87:b\'VarFormat\',88:b\'VarDateFromUI1\',89:b\'VarDateFromI2\',90:b\'VarDateFromI4\',91:b\'VarDateFromR4\',92:b\'VarDateFromR8\',93:b\'VarDateFromCy\',94:b\'VarDateFromStr\',95:b\'VarDateFromDisp\',96:b\'VarDateFromBool\',97:b\'VarFormatDateTime\',98:b\'VarCyFromUI1\',99:b\'VarCyFromI2\',100:b\'VarCyFromI4\',101:b\'VarCyFromR4\',102:b\'VarCyFromR8\',103:b\'VarCyFromDate\',104:b\'VarCyFromStr\',105:b\'VarCyFromDisp\',106:b\'VarCyFromBool\',107:b\'VarFormatNumber\',108:b\'VarBstrFromUI1\',109:b\'VarBstrFromI2\',110:b\'VarBstrFromI4\',111:b\'VarBstrFromR4\',112:b\'VarBstrFromR8\',113:b\'VarBstrFromCy\',114:b\'VarBstrFromDate\',115:b\'VarBstrFromDisp\',116:b\'VarBstrFromBool\',117:b\'VarFormatPercent\',118:b\'VarBoolFromUI1\',119:b\'VarBoolFromI2\',120:b\'VarBoolFromI4\',121:b\'VarBoolFromR4\',122:b\'VarBoolFromR8\',123:b\'VarBoolFromDate\',124:b\'VarBoolFromCy\',125:b\'VarBoolFromStr\',126:b\'VarBoolFromDisp\',127:b\'VarFormatCurrency\',128:b\'VarWeekdayName\',129:b\'VarMonthName\',130:b\'VarUI1FromI2\',131:b\'VarUI1FromI4\',132:b\'VarUI1FromR4\',133:b\'VarUI1FromR8\',134:b\'VarUI1FromCy\',135:b\'VarUI1FromDate\',136:b\'VarUI1FromStr\',137:b\'VarUI1FromDisp\',138:b\'VarUI1FromBool\',139:b\'VarFormatFromTokens\',140:b\'VarTokenizeFormatString\',141:b\'VarAdd\',142:b\'VarAnd\',143:b\'VarDiv\',144:b\'DllCanUnloadNow\',145:b\'DllGetClassObject\',146:b\'DispCallFunc\',147:b\'VariantChangeTypeEx\',148:b\'SafeArrayPtrOfIndex\',149:b\'SysStringByteLen\',150:b\'SysAllocStringByteLen\',151:b\'DllRegisterServer\',152:b\'VarEqv\',153:b\'VarIdiv\',154:b\'VarImp\',155:b\'VarMod\',156:b\'VarMul\',157:b\'VarOr\',158:b\'VarPow\',159:b\'VarSub\',160:b\'CreateTypeLib\',161:b\'LoadTypeLib\',162:b\'LoadRegTypeLib\',163:b\'RegisterTypeLib\',164:b\'QueryPathOfRegTypeLib\',165:b\'LHashValOfNameSys\',166:b\'LHashValOfNameSysA\',167:b\'VarXor\',168:b\'VarAbs\',169:b\'VarFix\',170:b\'OaBuildVersion\',171:b\'ClearCustData\',172:b\'VarInt\',173:b\'VarNeg\',174:b\'VarNot\',175:b\'VarRound\',176:b\'VarCmp\',177:b\'VarDecAdd\',178:b\'VarDecDiv\',179:b\'VarDecMul\',180:b\'CreateTypeLib2\',181:b\'VarDecSub\',182:b\'VarDecAbs\',183:b\'LoadTypeLibEx\',184:b\'SystemTimeToVariantTime\',185:b\'VariantTimeToSystemTime\',186:b\'UnRegisterTypeLib\',187:b\'VarDecFix\',188:b\'VarDecInt\',189:b\'VarDecNeg\',190:b\'VarDecFromUI1\',191:b\'VarDecFromI2\',192:b\'VarDecFromI4\',193:b\'VarDecFromR4\',194:b\'VarDecFromR8\',195:b\'VarDecFromDate\',196:b\'VarDecFromCy\',197:b\'VarDecFromStr\',198:b\'VarDecFromDisp\',199:b\'VarDecFromBool\',200:b\'GetErrorInfo\',201:b\'SetErrorInfo\',202:b\'CreateErrorInfo\',203:b\'VarDecRound\',204:b\'VarDecCmp\',205:b\'VarI2FromI1\',206:b\'VarI2FromUI2\',207:b\'VarI2FromUI4\',208:b\'VarI2FromDec\',209:b\'VarI4FromI1\',210:b\'VarI4FromUI2\',211:b\'VarI4FromUI4\',212:b\'VarI4FromDec\',213:b\'VarR4FromI1\',214:b\'VarR4FromUI2\',215:b\'VarR4FromUI4\',216:b\'VarR4FromDec\',217:b\'VarR8FromI1\',218:b\'VarR8FromUI2\',219:b\'VarR8FromUI4\',220:b\'VarR8FromDec\',221:b\'VarDateFromI1\',222:b\'VarDateFromUI2\',223:b\'VarDateFromUI4\',224:b\'VarDateFromDec\',225:b\'VarCyFromI1\',226:b\'VarCyFromUI2\',227:b\'VarCyFromUI4\',228:b\'VarCyFromDec\',229:b\'VarBstrFromI1\',230:b\'VarBstrFromUI2\',231:b\'VarBstrFromUI4\',232:b\'VarBstrFromDec\',233:b\'VarBoolFromI1\',234:b\'VarBoolFromUI2\',235:b\'VarBoolFromUI4\',236:b\'VarBoolFromDec\',237:b\'VarUI1FromI1\',238:b\'VarUI1FromUI2\',239:b\'VarUI1FromUI4\',240:b\'VarUI1FromDec\',241:b\'VarDecFromI1\',242:b\'VarDecFromUI2\',243:b\'VarDecFromUI4\',244:b\'VarI1FromUI1\',245:b\'VarI1FromI2\',246:b\'VarI1FromI4\',247:b\'VarI1FromR4\',248:b\'VarI1FromR8\',249:b\'VarI1FromDate\',250:b\'VarI1FromCy\',251:b\'VarI1FromStr\',252:b\'VarI1FromDisp\',253:b\'VarI1FromBool\',254:b\'VarI1FromUI2\',255:b\'VarI1FromUI4\',256:b\'VarI1FromDec\',257:b\'VarUI2FromUI1\',258:b\'VarUI2FromI2\',259:b\'VarUI2FromI4\',260:b\'VarUI2FromR4\',261:b\'VarUI2FromR8\',262:b\'VarUI2FromDate\',263:b\'VarUI2FromCy\',264:b\'VarUI2FromStr\',265:b\'VarUI2FromDisp\',266:b\'VarUI2FromBool\',267:b\'VarUI2FromI1\',268:b\'VarUI2FromUI4\',269:b\'VarUI2FromDec\',270:b\'VarUI4FromUI1\',271:b\'VarUI4FromI2\',272:b\'VarUI4FromI4\',273:b\'VarUI4FromR4\',274:b\'VarUI4FromR8\',275:b\'VarUI4FromDate\',276:b\'VarUI4FromCy\',277:b\'VarUI4FromStr\',278:b\'VarUI4FromDisp\',279:b\'VarUI4FromBool\',280:b\'VarUI4FromI1\',281:b\'VarUI4FromUI2\',282:b\'VarUI4FromDec\',283:b\'BSTR_UserSize\',284:b\'BSTR_UserMarshal\',285:b\'BSTR_UserUnmarshal\',286:b\'BSTR_UserFree\',287:b\'VARIANT_UserSize\',288:b\'VARIANT_UserMarshal\',289:b\'VARIANT_UserUnmarshal\',290:b\'VARIANT_UserFree\',291:b\'LPSAFEARRAY_UserSize\',292:b\'LPSAFEARRAY_UserMarshal\',293:b\'LPSAFEARRAY_UserUnmarshal\',294:b\'LPSAFEARRAY_UserFree\',295:b\'LPSAFEARRAY_Size\',296:b\'LPSAFEARRAY_Marshal\',297:b\'LPSAFEARRAY_Unmarshal\',298:b\'VarDecCmpR8\',299:b\'VarCyAdd\',300:b\'DllUnregisterServer\',301:b\'OACreateTypeLib2\',303:b\'VarCyMul\',304:b\'VarCyMulI4\',305:b\'VarCySub\',306:b\'VarCyAbs\',307:b\'VarCyFix\',308:b\'VarCyInt\',309:b\'VarCyNeg\',310:b\'VarCyRound\',311:b\'VarCyCmp\',312:b\'VarCyCmpR8\',313:b\'VarBstrCat\',314:b\'VarBstrCmp\',315:b\'VarR8Pow\',316:b\'VarR4CmpR8\',317:b\'VarR8Round\',318:b\'VarCat\',319:b\'VarDateFromUdateEx\',322:b\'GetRecordInfoFromGuids\',323:b\'GetRecordInfoFromTypeInfo\',325:b\'SetVarConversionLocaleSetting\',326:b\'GetVarConversionLocaleSetting\',327:b\'SetOaNoCache\',329:b\'VarCyMulI8\',330:b\'VarDateFromUdate\',331:b\'VarUdateFromDate\',332:b\'GetAltMonthNames\',333:b\'VarI8FromUI1\',334:b\'VarI8FromI2\',335:b\'VarI8FromR4\',336:b\'VarI8FromR8\',337:b\'VarI8FromCy\',338:b\'VarI8FromDate\',339:b\'VarI8FromStr\',340:b\'VarI8FromDisp\',341:b\'VarI8FromBool\',342:b\'VarI8FromI1\',343:b\'VarI8FromUI2\',344:b\'VarI8FromUI4\',345:b\'VarI8FromDec\',346:b\'VarI2FromI8\',347:b\'VarI2FromUI8\',348:b\'VarI4FromI8\',349:b\'VarI4FromUI8\',360:b\'VarR4FromI8\',361:b\'VarR4FromUI8\',362:b\'VarR8FromI8\',363:b\'VarR8FromUI8\',364:b\'VarDateFromI8\',365:b\'VarDateFromUI8\',366:b\'VarCyFromI8\',367:b\'VarCyFromUI8\',368:b\'VarBstrFromI8\',369:b\'VarBstrFromUI8\',370:b\'VarBoolFromI8\',371:b\'VarBoolFromUI8\',372:b\'VarUI1FromI8\',373:b\'VarUI1FromUI8\',374:b\'VarDecFromI8\',375:b\'VarDecFromUI8\',376:b\'VarI1FromI8\',377:b\'VarI1FromUI8\',378:b\'VarUI2FromI8\',379:b\'VarUI2FromUI8\',401:b\'OleLoadPictureEx\',402:b\'OleLoadPictureFileEx\',411:b\'SafeArrayCreateVector\',412:b\'SafeArrayCopyData\',413:b\'VectorFromBstr\',414:b\'BstrFromVector\',415:b\'OleIconToCursor\',416:b\'OleCreatePropertyFrameIndirect\',417:b\'OleCreatePropertyFrame\',418:b\'OleLoadPicture\',419:b\'OleCreatePictureIndirect\',420:b\'OleCreateFontIndirect\',421:b\'OleTranslateColor\',422:b\'OleLoadPictureFile\',423:b\'OleSavePictureFile\',424:b\'OleLoadPicturePath\',425:b\'VarUI4FromI8\',426:b\'VarUI4FromUI8\',427:b\'VarI8FromUI8\',428:b\'VarUI8FromI8\',429:b\'VarUI8FromUI1\',430:b\'VarUI8FromI2\',431:b\'VarUI8FromR4\',432:b\'VarUI8FromR8\',433:b\'VarUI8FromCy\',434:b\'VarUI8FromDate\',435:b\'VarUI8FromStr\',436:b\'VarUI8FromDisp\',437:b\'VarUI8FromBool\',438:b\'VarUI8FromI1\',439:b\'VarUI8FromUI2\',440:b\'VarUI8FromUI4\',441:b\'VarUI8FromDec\',442:b\'RegisterTypeLibForUser\',443:b\'UnRegisterTypeLibForUser\'}\nws2_32_ord_names={1:b\'accept\',2:b\'bind\',3:b\'closesocket\',4:b\'connect\',5:b\'getpeername\',6:b\'getsockname\',7:b\'getsockopt\',8:b\'htonl\',9:b\'htons\',10:b\'ioctlsocket\',11:b\'inet_addr\',12:b\'inet_ntoa\',13:b\'listen\',14:b\'ntohl\',15:b\'ntohs\',16:b\'recv\',17:b\'recvfrom\',18:b\'select\',19:b\'send\',20:b\'sendto\',21:b\'setsockopt\',22:b\'shutdown\',23:b\'socket\',24:b\'GetAddrInfoW\',25:b\'GetNameInfoW\',26:b\'WSApSetPostRoutine\',27:b\'FreeAddrInfoW\',28:b\'WPUCompleteOverlappedRequest\',29:b\'WSAAccept\',30:b\'WSAAddressToStringA\',31:b\'WSAAddressToStringW\',32:b\'WSACloseEvent\',33:b\'WSAConnect\',34:b\'WSACreateEvent\',35:b\'WSADuplicateSocketA\',36:b\'WSADuplicateSocketW\',37:b\'WSAEnumNameSpaceProvidersA\',38:b\'WSAEnumNameSpaceProvidersW\',39:b\'WSAEnumNetworkEvents\',40:b\'WSAEnumProtocolsA\',41:b\'WSAEnumProtocolsW\',42:b\'WSAEventSelect\',43:b\'WSAGetOverlappedResult\',44:b\'WSAGetQOSByName\',45:b\'WSAGetServiceClassInfoA\',46:b\'WSAGetServiceClassInfoW\',47:b\'WSAGetServiceClassNameByClassIdA\',48:b\'WSAGetServiceClassNameByClassIdW\',49:b\'WSAHtonl\',50:b\'WSAHtons\',51:b\'gethostbyaddr\',52:b\'gethostbyname\',53:b\'getprotobyname\',54:b\'getprotobynumber\',55:b\'getservbyname\',56:b\'getservbyport\',57:b\'gethostname\',58:b\'WSAInstallServiceClassA\',59:b\'WSAInstallServiceClassW\',60:b\'WSAIoctl\',61:b\'WSAJoinLeaf\',62:b\'WSALookupServiceBeginA\',63:b\'WSALookupServiceBeginW\',64:b\'WSALookupServiceEnd\',65:b\'WSALookupServiceNextA\',66:b\'WSALookupServiceNextW\',67:b\'WSANSPIoctl\',68:b\'WSANtohl\',69:b\'WSANtohs\',70:b\'WSAProviderConfigChange\',71:b\'WSARecv\',72:b\'WSARecvDisconnect\',73:b\'WSARecvFrom\',74:b\'WSARemoveServiceClass\',75:b\'WSAResetEvent\',76:b\'WSASend\',77:b\'WSASendDisconnect\',78:b\'WSASendTo\',79:b\'WSASetEvent\',80:b\'WSASetServiceA\',81:b\'WSASetServiceW\',82:b\'WSASocketA\',83:b\'WSASocketW\',84:b\'WSAStringToAddressA\',85:b\'WSAStringToAddressW\',86:b\'WSAWaitForMultipleEvents\',87:b\'WSCDeinstallProvider\',88:b\'WSCEnableNSProvider\',89:b\'WSCEnumProtocols\',90:b\'WSCGetProviderPath\',91:b\'WSCInstallNameSpace\',92:b\'WSCInstallProvider\',93:b\'WSCUnInstallNameSpace\',94:b\'WSCUpdateProvider\',95:b\'WSCWriteNameSpaceOrder\',96:b\'WSCWriteProviderOrder\',97:b\'freeaddrinfo\',98:b\'getaddrinfo\',99:b\'getnameinfo\',101:b\'WSAAsyncSelect\',102:b\'WSAAsyncGetHostByAddr\',103:b\'WSAAsyncGetHostByName\',104:b\'WSAAsyncGetProtoByNumber\',105:b\'WSAAsyncGetProtoByName\',106:b\'WSAAsyncGetServByPort\',107:b\'WSAAsyncGetServByName\',108:b\'WSACancelAsyncRequest\',109:b\'WSASetBlockingHook\',110:b\'WSAUnhookBlockingHook\',111:b\'WSAGetLastError\',112:b\'WSASetLastError\',113:b\'WSACancelBlockingCall\',114:b\'WSAIsBlocking\',115:b\'WSAStartup\',116:b\'WSACleanup\',151:b\'__WSAFDIsSet\',500:b\'WEP\'}\n\nords = {\n    b"ws2_32.dll": ws2_32_ord_names,\n    b"wsock32.dll": ws2_32_ord_names,\n    b"oleaut32.dll": oleaut32_ord_names,\n}\n\n\ndef formatOrdString(ord_val):\n    return "ord{}".format(ord_val).encode()\n\n\ndef ordLookup(libname, ord_val, make_name=False):\n    names = ords.get(libname.lower())\n    if names is None:\n        if make_name is True:\n            return formatOrdString(ord_val)\n        return None\n    name = names.get(ord_val)\n    if name is None:\n        return formatOrdString(ord_val)\n    return name\n\n\ncodecs.register_error(\'backslashreplace_\',codecs.lookup_error(\'backslashreplace\'))\nlong=int\ndef lru_cache(maxsize=128,typed=False,copy=False):\n    if not copy:return functools.lru_cache(maxsize,typed)\n    def decorator(f):\n        cached_func=functools.lru_cache(maxsize,typed)(f)\n        @functools.wraps(f)\n        def wrapper(*args,**kwargs):return copymod.copy(cached_func(*args,**kwargs))\n        return wrapper\n    return decorator\n@lru_cache(maxsize=2048)\ndef cache_adjust_SectionAlignment(val,section_alignment,file_alignment):\n    if section_alignment<4096:section_alignment=file_alignment\n    if section_alignment and val%section_alignment:return section_alignment*int(val/section_alignment)\n    return val\ndef count_zeroes(data):return data.count(0)\nfast_load=False\nMAX_STRING_LENGTH=1048576\nMAX_IMPORT_SYMBOLS=8192\nMAX_IMPORT_NAME_LENGTH=512\nMAX_DLL_LENGTH=512\nMAX_SYMBOL_NAME_LENGTH=512\nMAX_SECTIONS=2048\nMAX_RESOURCE_ENTRIES=32768\nMAX_RESOURCE_DEPTH=32\nMAX_SYMBOL_EXPORT_COUNT=8192\nIMAGE_DOS_SIGNATURE=23117\nIMAGE_DOSZM_SIGNATURE=19802\nIMAGE_NE_SIGNATURE=17742\nIMAGE_LE_SIGNATURE=17740\nIMAGE_LX_SIGNATURE=22604\nIMAGE_TE_SIGNATURE=23126\nIMAGE_NT_SIGNATURE=17744\nIMAGE_NUMBEROF_DIRECTORY_ENTRIES=16\nIMAGE_ORDINAL_FLAG=2147483648\nIMAGE_ORDINAL_FLAG64=0x8000000000000000\nOPTIONAL_HEADER_MAGIC_PE=267\nOPTIONAL_HEADER_MAGIC_PE_PLUS=523\ndef two_way_dict(pairs):return dict([(e[1],e[0])for e in pairs]+pairs)\ndirectory_entry_types=[(\'IMAGE_DIRECTORY_ENTRY_EXPORT\',0),(\'IMAGE_DIRECTORY_ENTRY_IMPORT\',1),(\'IMAGE_DIRECTORY_ENTRY_RESOURCE\',2),(\'IMAGE_DIRECTORY_ENTRY_EXCEPTION\',3),(\'IMAGE_DIRECTORY_ENTRY_SECURITY\',4),(\'IMAGE_DIRECTORY_ENTRY_BASERELOC\',5),(\'IMAGE_DIRECTORY_ENTRY_DEBUG\',6),(\'IMAGE_DIRECTORY_ENTRY_COPYRIGHT\',7),(\'IMAGE_DIRECTORY_ENTRY_GLOBALPTR\',8),(\'IMAGE_DIRECTORY_ENTRY_TLS\',9),(\'IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG\',10),(\'IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT\',11),(\'IMAGE_DIRECTORY_ENTRY_IAT\',12),(\'IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT\',13),(\'IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR\',14),(\'IMAGE_DIRECTORY_ENTRY_RESERVED\',15)]\nDIRECTORY_ENTRY=two_way_dict(directory_entry_types)\nimage_characteristics=[(\'IMAGE_FILE_RELOCS_STRIPPED\',1),(\'IMAGE_FILE_EXECUTABLE_IMAGE\',2),(\'IMAGE_FILE_LINE_NUMS_STRIPPED\',4),(\'IMAGE_FILE_LOCAL_SYMS_STRIPPED\',8),(\'IMAGE_FILE_AGGRESIVE_WS_TRIM\',16),(\'IMAGE_FILE_LARGE_ADDRESS_AWARE\',32),(\'IMAGE_FILE_16BIT_MACHINE\',64),(\'IMAGE_FILE_BYTES_REVERSED_LO\',128),(\'IMAGE_FILE_32BIT_MACHINE\',256),(\'IMAGE_FILE_DEBUG_STRIPPED\',512),(\'IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP\',1024),(\'IMAGE_FILE_NET_RUN_FROM_SWAP\',2048),(\'IMAGE_FILE_SYSTEM\',4096),(\'IMAGE_FILE_DLL\',8192),(\'IMAGE_FILE_UP_SYSTEM_ONLY\',16384),(\'IMAGE_FILE_BYTES_REVERSED_HI\',32768)]\nIMAGE_CHARACTERISTICS=two_way_dict(image_characteristics)\nsection_characteristics=[(\'IMAGE_SCN_TYPE_REG\',0),(\'IMAGE_SCN_TYPE_DSECT\',1),(\'IMAGE_SCN_TYPE_NOLOAD\',2),(\'IMAGE_SCN_TYPE_GROUP\',4),(\'IMAGE_SCN_TYPE_NO_PAD\',8),(\'IMAGE_SCN_TYPE_COPY\',16),(\'IMAGE_SCN_CNT_CODE\',32),(\'IMAGE_SCN_CNT_INITIALIZED_DATA\',64),(\'IMAGE_SCN_CNT_UNINITIALIZED_DATA\',128),(\'IMAGE_SCN_LNK_OTHER\',256),(\'IMAGE_SCN_LNK_INFO\',512),(\'IMAGE_SCN_LNK_OVER\',1024),(\'IMAGE_SCN_LNK_REMOVE\',2048),(\'IMAGE_SCN_LNK_COMDAT\',4096),(\'IMAGE_SCN_MEM_PROTECTED\',16384),(\'IMAGE_SCN_NO_DEFER_SPEC_EXC\',16384),(\'IMAGE_SCN_GPREL\',32768),(\'IMAGE_SCN_MEM_FARDATA\',32768),(\'IMAGE_SCN_MEM_SYSHEAP\',65536),(\'IMAGE_SCN_MEM_PURGEABLE\',131072),(\'IMAGE_SCN_MEM_16BIT\',131072),(\'IMAGE_SCN_MEM_LOCKED\',262144),(\'IMAGE_SCN_MEM_PRELOAD\',524288),(\'IMAGE_SCN_ALIGN_1BYTES\',1048576),(\'IMAGE_SCN_ALIGN_2BYTES\',2097152),(\'IMAGE_SCN_ALIGN_4BYTES\',3145728),(\'IMAGE_SCN_ALIGN_8BYTES\',4194304),(\'IMAGE_SCN_ALIGN_16BYTES\',5242880),(\'IMAGE_SCN_ALIGN_32BYTES\',6291456),(\'IMAGE_SCN_ALIGN_64BYTES\',7340032),(\'IMAGE_SCN_ALIGN_128BYTES\',8388608),(\'IMAGE_SCN_ALIGN_256BYTES\',9437184),(\'IMAGE_SCN_ALIGN_512BYTES\',10485760),(\'IMAGE_SCN_ALIGN_1024BYTES\',11534336),(\'IMAGE_SCN_ALIGN_2048BYTES\',12582912),(\'IMAGE_SCN_ALIGN_4096BYTES\',13631488),(\'IMAGE_SCN_ALIGN_8192BYTES\',14680064),(\'IMAGE_SCN_ALIGN_MASK\',15728640),(\'IMAGE_SCN_LNK_NRELOC_OVFL\',16777216),(\'IMAGE_SCN_MEM_DISCARDABLE\',33554432),(\'IMAGE_SCN_MEM_NOT_CACHED\',67108864),(\'IMAGE_SCN_MEM_NOT_PAGED\',134217728),(\'IMAGE_SCN_MEM_SHARED\',268435456),(\'IMAGE_SCN_MEM_EXECUTE\',536870912),(\'IMAGE_SCN_MEM_READ\',1073741824),(\'IMAGE_SCN_MEM_WRITE\',2147483648)]\nSECTION_CHARACTERISTICS=two_way_dict(section_characteristics)\ndebug_types=[(\'IMAGE_DEBUG_TYPE_UNKNOWN\',0),(\'IMAGE_DEBUG_TYPE_COFF\',1),(\'IMAGE_DEBUG_TYPE_CODEVIEW\',2),(\'IMAGE_DEBUG_TYPE_FPO\',3),(\'IMAGE_DEBUG_TYPE_MISC\',4),(\'IMAGE_DEBUG_TYPE_EXCEPTION\',5),(\'IMAGE_DEBUG_TYPE_FIXUP\',6),(\'IMAGE_DEBUG_TYPE_OMAP_TO_SRC\',7),(\'IMAGE_DEBUG_TYPE_OMAP_FROM_SRC\',8),(\'IMAGE_DEBUG_TYPE_BORLAND\',9),(\'IMAGE_DEBUG_TYPE_RESERVED10\',10),(\'IMAGE_DEBUG_TYPE_CLSID\',11),(\'IMAGE_DEBUG_TYPE_VC_FEATURE\',12),(\'IMAGE_DEBUG_TYPE_POGO\',13),(\'IMAGE_DEBUG_TYPE_ILTCG\',14),(\'IMAGE_DEBUG_TYPE_MPX\',15),(\'IMAGE_DEBUG_TYPE_REPRO\',16),(\'IMAGE_DEBUG_TYPE_EX_DLLCHARACTERISTICS\',20)]\nDEBUG_TYPE=two_way_dict(debug_types)\nsubsystem_types=[(\'IMAGE_SUBSYSTEM_UNKNOWN\',0),(\'IMAGE_SUBSYSTEM_NATIVE\',1),(\'IMAGE_SUBSYSTEM_WINDOWS_GUI\',2),(\'IMAGE_SUBSYSTEM_WINDOWS_CUI\',3),(\'IMAGE_SUBSYSTEM_OS2_CUI\',5),(\'IMAGE_SUBSYSTEM_POSIX_CUI\',7),(\'IMAGE_SUBSYSTEM_NATIVE_WINDOWS\',8),(\'IMAGE_SUBSYSTEM_WINDOWS_CE_GUI\',9),(\'IMAGE_SUBSYSTEM_EFI_APPLICATION\',10),(\'IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER\',11),(\'IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER\',12),(\'IMAGE_SUBSYSTEM_EFI_ROM\',13),(\'IMAGE_SUBSYSTEM_XBOX\',14),(\'IMAGE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION\',16)]\nSUBSYSTEM_TYPE=two_way_dict(subsystem_types)\nmachine_types=[(\'IMAGE_FILE_MACHINE_UNKNOWN\',0),(\'IMAGE_FILE_MACHINE_I386\',332),(\'IMAGE_FILE_MACHINE_R3000\',354),(\'IMAGE_FILE_MACHINE_R4000\',358),(\'IMAGE_FILE_MACHINE_R10000\',360),(\'IMAGE_FILE_MACHINE_WCEMIPSV2\',361),(\'IMAGE_FILE_MACHINE_ALPHA\',388),(\'IMAGE_FILE_MACHINE_SH3\',418),(\'IMAGE_FILE_MACHINE_SH3DSP\',419),(\'IMAGE_FILE_MACHINE_SH3E\',420),(\'IMAGE_FILE_MACHINE_SH4\',422),(\'IMAGE_FILE_MACHINE_SH5\',424),(\'IMAGE_FILE_MACHINE_ARM\',448),(\'IMAGE_FILE_MACHINE_THUMB\',450),(\'IMAGE_FILE_MACHINE_ARMNT\',452),(\'IMAGE_FILE_MACHINE_AM33\',467),(\'IMAGE_FILE_MACHINE_POWERPC\',496),(\'IMAGE_FILE_MACHINE_POWERPCFP\',497),(\'IMAGE_FILE_MACHINE_IA64\',512),(\'IMAGE_FILE_MACHINE_MIPS16\',614),(\'IMAGE_FILE_MACHINE_ALPHA64\',644),(\'IMAGE_FILE_MACHINE_AXP64\',644),(\'IMAGE_FILE_MACHINE_MIPSFPU\',870),(\'IMAGE_FILE_MACHINE_MIPSFPU16\',1126),(\'IMAGE_FILE_MACHINE_TRICORE\',1312),(\'IMAGE_FILE_MACHINE_CEF\',3311),(\'IMAGE_FILE_MACHINE_EBC\',3772),(\'IMAGE_FILE_MACHINE_RISCV32\',20530),(\'IMAGE_FILE_MACHINE_RISCV64\',20580),(\'IMAGE_FILE_MACHINE_RISCV128\',20776),(\'IMAGE_FILE_MACHINE_LOONGARCH32\',25138),(\'IMAGE_FILE_MACHINE_LOONGARCH64\',25188),(\'IMAGE_FILE_MACHINE_AMD64\',34404),(\'IMAGE_FILE_MACHINE_M32R\',36929),(\'IMAGE_FILE_MACHINE_ARM64\',43620),(\'IMAGE_FILE_MACHINE_CEE\',49390)]\nMACHINE_TYPE=two_way_dict(machine_types)\nrelocation_types=[(\'IMAGE_REL_BASED_ABSOLUTE\',0),(\'IMAGE_REL_BASED_HIGH\',1),(\'IMAGE_REL_BASED_LOW\',2),(\'IMAGE_REL_BASED_HIGHLOW\',3),(\'IMAGE_REL_BASED_HIGHADJ\',4),(\'IMAGE_REL_BASED_MIPS_JMPADDR\',5),(\'IMAGE_REL_BASED_SECTION\',6),(\'IMAGE_REL_BASED_REL\',7),(\'IMAGE_REL_BASED_MIPS_JMPADDR16\',9),(\'IMAGE_REL_BASED_IA64_IMM64\',9),(\'IMAGE_REL_BASED_DIR64\',10),(\'IMAGE_REL_BASED_HIGH3ADJ\',11)]\nRELOCATION_TYPE=two_way_dict(relocation_types)\ndll_characteristics=[(\'IMAGE_LIBRARY_PROCESS_INIT\',1),(\'IMAGE_LIBRARY_PROCESS_TERM\',2),(\'IMAGE_LIBRARY_THREAD_INIT\',4),(\'IMAGE_LIBRARY_THREAD_TERM\',8),(\'IMAGE_DLLCHARACTERISTICS_HIGH_ENTROPY_VA\',32),(\'IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE\',64),(\'IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY\',128),(\'IMAGE_DLLCHARACTERISTICS_NX_COMPAT\',256),(\'IMAGE_DLLCHARACTERISTICS_NO_ISOLATION\',512),(\'IMAGE_DLLCHARACTERISTICS_NO_SEH\',1024),(\'IMAGE_DLLCHARACTERISTICS_NO_BIND\',2048),(\'IMAGE_DLLCHARACTERISTICS_APPCONTAINER\',4096),(\'IMAGE_DLLCHARACTERISTICS_WDM_DRIVER\',8192),(\'IMAGE_DLLCHARACTERISTICS_GUARD_CF\',16384),(\'IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE\',32768)]\nDLL_CHARACTERISTICS=two_way_dict(dll_characteristics)\nex_dll_characteristics=[(\'IMAGE_DLLCHARACTERISTICS_EX_CET_COMPAT\',1),(\'IMAGE_DLLCHARACTERISTICS_EX_CET_COMPAT_STRICT_MODE\',2),(\'IMAGE_DLLCHARACTERISTICS_EX_CET_SET_CONTEXT_IP_VALIDATION_RELAXED_MODE\',4),(\'IMAGE_DLLCHARACTERISTICS_EX_CET_DYNAMIC_APIS_ALLOW_IN_PROC\',8),(\'IMAGE_DLLCHARACTERISTICS_EX_CET_RESERVED_1\',16),(\'IMAGE_DLLCHARACTERISTICS_EX_CET_RESERVED_2\',32)]\nEX_DLL_CHARACTERISTICS=two_way_dict(ex_dll_characteristics)\nMIN_VALID_FILE_ALIGNMENT=512\nSECTOR_SIZE=512\nunwind_info_flags=[(\'UNW_FLAG_EHANDLER\',1),(\'UNW_FLAG_UHANDLER\',2),(\'UNW_FLAG_CHAININFO\',4)]\nUNWIND_INFO_FLAGS=two_way_dict(unwind_info_flags)\nregisters=[(\'RAX\',0),(\'RCX\',1),(\'RDX\',2),(\'RBX\',3),(\'RSP\',4),(\'RBP\',5),(\'RSI\',6),(\'RDI\',7),(\'R8\',8),(\'R9\',9),(\'R10\',10),(\'R11\',11),(\'R12\',12),(\'R13\',13),(\'R14\',14),(\'R15\',15)]\nREGISTERS=two_way_dict(registers)\nUWOP_PUSH_NONVOL=0\nUWOP_ALLOC_LARGE=1\nUWOP_ALLOC_SMALL=2\nUWOP_SET_FPREG=3\nUWOP_SAVE_NONVOL=4\nUWOP_SAVE_NONVOL_FAR=5\nUWOP_EPILOG=6\nUWOP_SAVE_XMM128=8\nUWOP_SAVE_XMM128_FAR=9\nUWOP_PUSH_MACHFRAME=10\nresource_type=[(\'RT_CURSOR\',1),(\'RT_BITMAP\',2),(\'RT_ICON\',3),(\'RT_MENU\',4),(\'RT_DIALOG\',5),(\'RT_STRING\',6),(\'RT_FONTDIR\',7),(\'RT_FONT\',8),(\'RT_ACCELERATOR\',9),(\'RT_RCDATA\',10),(\'RT_MESSAGETABLE\',11),(\'RT_GROUP_CURSOR\',12),(\'RT_GROUP_ICON\',14),(\'RT_VERSION\',16),(\'RT_DLGINCLUDE\',17),(\'RT_PLUGPLAY\',19),(\'RT_VXD\',20),(\'RT_ANICURSOR\',21),(\'RT_ANIICON\',22),(\'RT_HTML\',23),(\'RT_MANIFEST\',24)]\nRESOURCE_TYPE=two_way_dict(resource_type)\nlang=[(\'LANG_NEUTRAL\',0),(\'LANG_INVARIANT\',127),(\'LANG_AFRIKAANS\',54),(\'LANG_ALBANIAN\',28),(\'LANG_ARABIC\',1),(\'LANG_ARMENIAN\',43),(\'LANG_ASSAMESE\',77),(\'LANG_AZERI\',44),(\'LANG_BASQUE\',45),(\'LANG_BELARUSIAN\',35),(\'LANG_BENGALI\',69),(\'LANG_BULGARIAN\',2),(\'LANG_CATALAN\',3),(\'LANG_CHINESE\',4),(\'LANG_CROATIAN\',26),(\'LANG_CZECH\',5),(\'LANG_DANISH\',6),(\'LANG_DIVEHI\',101),(\'LANG_DUTCH\',19),(\'LANG_ENGLISH\',9),(\'LANG_ESTONIAN\',37),(\'LANG_FAEROESE\',56),(\'LANG_FARSI\',41),(\'LANG_FINNISH\',11),(\'LANG_FRENCH\',12),(\'LANG_GALICIAN\',86),(\'LANG_GEORGIAN\',55),(\'LANG_GERMAN\',7),(\'LANG_GREEK\',8),(\'LANG_GUJARATI\',71),(\'LANG_HEBREW\',13),(\'LANG_HINDI\',57),(\'LANG_HUNGARIAN\',14),(\'LANG_ICELANDIC\',15),(\'LANG_INDONESIAN\',33),(\'LANG_ITALIAN\',16),(\'LANG_JAPANESE\',17),(\'LANG_KANNADA\',75),(\'LANG_KASHMIRI\',96),(\'LANG_KAZAK\',63),(\'LANG_KONKANI\',87),(\'LANG_KOREAN\',18),(\'LANG_KYRGYZ\',64),(\'LANG_LATVIAN\',38),(\'LANG_LITHUANIAN\',39),(\'LANG_MACEDONIAN\',47),(\'LANG_MALAY\',62),(\'LANG_MALAYALAM\',76),(\'LANG_MANIPURI\',88),(\'LANG_MARATHI\',78),(\'LANG_MONGOLIAN\',80),(\'LANG_NEPALI\',97),(\'LANG_NORWEGIAN\',20),(\'LANG_ORIYA\',72),(\'LANG_POLISH\',21),(\'LANG_PORTUGUESE\',22),(\'LANG_PUNJABI\',70),(\'LANG_ROMANIAN\',24),(\'LANG_RUSSIAN\',25),(\'LANG_SANSKRIT\',79),(\'LANG_SERBIAN\',26),(\'LANG_SINDHI\',89),(\'LANG_SLOVAK\',27),(\'LANG_SLOVENIAN\',36),(\'LANG_SPANISH\',10),(\'LANG_SWAHILI\',65),(\'LANG_SWEDISH\',29),(\'LANG_SYRIAC\',90),(\'LANG_TAMIL\',73),(\'LANG_TATAR\',68),(\'LANG_TELUGU\',74),(\'LANG_THAI\',30),(\'LANG_TURKISH\',31),(\'LANG_UKRAINIAN\',34),(\'LANG_URDU\',32),(\'LANG_UZBEK\',67),(\'LANG_VIETNAMESE\',42),(\'LANG_GAELIC\',60),(\'LANG_MALTESE\',58),(\'LANG_MAORI\',40),(\'LANG_RHAETO_ROMANCE\',23),(\'LANG_SAAMI\',59),(\'LANG_SORBIAN\',46),(\'LANG_SUTU\',48),(\'LANG_TSONGA\',49),(\'LANG_TSWANA\',50),(\'LANG_VENDA\',51),(\'LANG_XHOSA\',52),(\'LANG_ZULU\',53),(\'LANG_ESPERANTO\',143),(\'LANG_WALON\',144),(\'LANG_CORNISH\',145),(\'LANG_WELSH\',146),(\'LANG_BRETON\',147)]\nLANG=two_way_dict(lang)\nsublang=[(\'SUBLANG_NEUTRAL\',0),(\'SUBLANG_DEFAULT\',1),(\'SUBLANG_SYS_DEFAULT\',2),(\'SUBLANG_ARABIC_SAUDI_ARABIA\',1),(\'SUBLANG_ARABIC_IRAQ\',2),(\'SUBLANG_ARABIC_EGYPT\',3),(\'SUBLANG_ARABIC_LIBYA\',4),(\'SUBLANG_ARABIC_ALGERIA\',5),(\'SUBLANG_ARABIC_MOROCCO\',6),(\'SUBLANG_ARABIC_TUNISIA\',7),(\'SUBLANG_ARABIC_OMAN\',8),(\'SUBLANG_ARABIC_YEMEN\',9),(\'SUBLANG_ARABIC_SYRIA\',10),(\'SUBLANG_ARABIC_JORDAN\',11),(\'SUBLANG_ARABIC_LEBANON\',12),(\'SUBLANG_ARABIC_KUWAIT\',13),(\'SUBLANG_ARABIC_UAE\',14),(\'SUBLANG_ARABIC_BAHRAIN\',15),(\'SUBLANG_ARABIC_QATAR\',16),(\'SUBLANG_AZERI_LATIN\',1),(\'SUBLANG_AZERI_CYRILLIC\',2),(\'SUBLANG_CHINESE_TRADITIONAL\',1),(\'SUBLANG_CHINESE_SIMPLIFIED\',2),(\'SUBLANG_CHINESE_HONGKONG\',3),(\'SUBLANG_CHINESE_SINGAPORE\',4),(\'SUBLANG_CHINESE_MACAU\',5),(\'SUBLANG_DUTCH\',1),(\'SUBLANG_DUTCH_BELGIAN\',2),(\'SUBLANG_ENGLISH_US\',1),(\'SUBLANG_ENGLISH_UK\',2),(\'SUBLANG_ENGLISH_AUS\',3),(\'SUBLANG_ENGLISH_CAN\',4),(\'SUBLANG_ENGLISH_NZ\',5),(\'SUBLANG_ENGLISH_EIRE\',6),(\'SUBLANG_ENGLISH_SOUTH_AFRICA\',7),(\'SUBLANG_ENGLISH_JAMAICA\',8),(\'SUBLANG_ENGLISH_CARIBBEAN\',9),(\'SUBLANG_ENGLISH_BELIZE\',10),(\'SUBLANG_ENGLISH_TRINIDAD\',11),(\'SUBLANG_ENGLISH_ZIMBABWE\',12),(\'SUBLANG_ENGLISH_PHILIPPINES\',13),(\'SUBLANG_FRENCH\',1),(\'SUBLANG_FRENCH_BELGIAN\',2),(\'SUBLANG_FRENCH_CANADIAN\',3),(\'SUBLANG_FRENCH_SWISS\',4),(\'SUBLANG_FRENCH_LUXEMBOURG\',5),(\'SUBLANG_FRENCH_MONACO\',6),(\'SUBLANG_GERMAN\',1),(\'SUBLANG_GERMAN_SWISS\',2),(\'SUBLANG_GERMAN_AUSTRIAN\',3),(\'SUBLANG_GERMAN_LUXEMBOURG\',4),(\'SUBLANG_GERMAN_LIECHTENSTEIN\',5),(\'SUBLANG_ITALIAN\',1),(\'SUBLANG_ITALIAN_SWISS\',2),(\'SUBLANG_KASHMIRI_SASIA\',2),(\'SUBLANG_KASHMIRI_INDIA\',2),(\'SUBLANG_KOREAN\',1),(\'SUBLANG_LITHUANIAN\',1),(\'SUBLANG_MALAY_MALAYSIA\',1),(\'SUBLANG_MALAY_BRUNEI_DARUSSALAM\',2),(\'SUBLANG_NEPALI_INDIA\',2),(\'SUBLANG_NORWEGIAN_BOKMAL\',1),(\'SUBLANG_NORWEGIAN_NYNORSK\',2),(\'SUBLANG_PORTUGUESE\',2),(\'SUBLANG_PORTUGUESE_BRAZILIAN\',1),(\'SUBLANG_SERBIAN_LATIN\',2),(\'SUBLANG_SERBIAN_CYRILLIC\',3),(\'SUBLANG_SPANISH\',1),(\'SUBLANG_SPANISH_MEXICAN\',2),(\'SUBLANG_SPANISH_MODERN\',3),(\'SUBLANG_SPANISH_GUATEMALA\',4),(\'SUBLANG_SPANISH_COSTA_RICA\',5),(\'SUBLANG_SPANISH_PANAMA\',6),(\'SUBLANG_SPANISH_DOMINICAN_REPUBLIC\',7),(\'SUBLANG_SPANISH_VENEZUELA\',8),(\'SUBLANG_SPANISH_COLOMBIA\',9),(\'SUBLANG_SPANISH_PERU\',10),(\'SUBLANG_SPANISH_ARGENTINA\',11),(\'SUBLANG_SPANISH_ECUADOR\',12),(\'SUBLANG_SPANISH_CHILE\',13),(\'SUBLANG_SPANISH_URUGUAY\',14),(\'SUBLANG_SPANISH_PARAGUAY\',15),(\'SUBLANG_SPANISH_BOLIVIA\',16),(\'SUBLANG_SPANISH_EL_SALVADOR\',17),(\'SUBLANG_SPANISH_HONDURAS\',18),(\'SUBLANG_SPANISH_NICARAGUA\',19),(\'SUBLANG_SPANISH_PUERTO_RICO\',20),(\'SUBLANG_SWEDISH\',1),(\'SUBLANG_SWEDISH_FINLAND\',2),(\'SUBLANG_URDU_PAKISTAN\',1),(\'SUBLANG_URDU_INDIA\',2),(\'SUBLANG_UZBEK_LATIN\',1),(\'SUBLANG_UZBEK_CYRILLIC\',2),(\'SUBLANG_DUTCH_SURINAM\',3),(\'SUBLANG_ROMANIAN\',1),(\'SUBLANG_ROMANIAN_MOLDAVIA\',2),(\'SUBLANG_RUSSIAN\',1),(\'SUBLANG_RUSSIAN_MOLDAVIA\',2),(\'SUBLANG_CROATIAN\',1),(\'SUBLANG_LITHUANIAN_CLASSIC\',2),(\'SUBLANG_GAELIC\',1),(\'SUBLANG_GAELIC_SCOTTISH\',2),(\'SUBLANG_GAELIC_MANX\',3)]\nSUBLANG=two_way_dict(sublang)\nSUBLANG=dict(sublang)\nfor(sublang_name,sublang_value)in sublang:\n    if sublang_value in SUBLANG:SUBLANG[sublang_value].append(sublang_name)\n    else:SUBLANG[sublang_value]=[sublang_name]\ndef get_sublang_name_for_lang(lang_value,sublang_value):\n    lang_name=LANG.get(lang_value,\'*unknown*\')\n    for sublang_name in SUBLANG.get(sublang_value,[]):\n        if lang_name in sublang_name:return sublang_name\n    return SUBLANG.get(sublang_value,[\'*unknown*\'])[0]\ndef parse_strings(data,counter,l):\n    i=0;error_count=0\n    while i<len(data):\n        data_slice=data[i:i+2]\n        if len(data_slice)<2:break\n        len_=struct.unpack(\'<h\',data_slice)[0];i+=2\n        if len_!=0 and 0<=len_*2<=len(data):\n            try:l[counter]=data[i:i+len_*2].decode(\'utf-16le\')\n            except UnicodeDecodeError:error_count+=1\n            if error_count>=3:break\n            i+=len_*2\n        counter+=1\ndef retrieve_flags(flag_dict,flag_filter):return[(flag,flag_dict[flag])for flag in flag_dict.keys()if isinstance(flag,(str,bytes))and flag.startswith(flag_filter)]\ndef set_flags(obj,flag_field,flags):\n    for(flag,value)in flags:\n        if value&flag_field:obj.__dict__[flag]=True\n        else:obj.__dict__[flag]=False\ndef power_of_two(val):return val!=0 and val&val-1==0\nclass AddressSet(set):\n    def __init__(self):super().__init__();self.min=None;self.max=None\n    def add(self,value):super().add(value);self.min=value if self.min is None else min(self.min,value);self.max=value if self.max is None else max(self.max,value)\n    def diff(self):return 0 if self.min is None or self.max is None else self.max-self.min\nclass UnicodeStringWrapperPostProcessor:\n    def __init__(self,pe,rva_ptr):self.pe=pe;self.rva_ptr=rva_ptr;self.string=None\n    def get_rva(self):return self.rva_ptr\n    def __str__(self):return self.decode(\'utf-8\',\'backslashreplace_\')\n    def decode(self,*args):\n        if not self.string:return\'\'\n        return self.string.decode(*args)\n    def invalidate(self):self=None\n    def render_pascal_16(self):\n        try:self.string=self.pe.get_string_u_at_rva(self.rva_ptr+2,max_length=self.get_pascal_16_length())\n        except PEFormatError:self.pe.get_warnings().append(\'Failed rendering pascal string, attempting to read from RVA 0x{0:x}\'.format(self.rva_ptr+2))\n    def get_pascal_16_length(self):return self.__get_word_value_at_rva(self.rva_ptr)\n    def __get_word_value_at_rva(self,rva):\n        try:data=self.pe.get_data(rva,2)\n        except PEFormatError:return False\n        if len(data)<2:return False\n        return struct.unpack(\'<H\',data)[0]\n    def ask_unicode_16(self,next_rva_ptr):\n        if self.__get_word_value_at_rva(next_rva_ptr-2)==0:self.length=next_rva_ptr-self.rva_ptr;return True\n        return False\n    def render_unicode_16(self):\n        try:self.string=self.pe.get_string_u_at_rva(self.rva_ptr)\n        except PEFormatError:self.pe.get_warnings().append(\'Failed rendering unicode string, attempting to read from RVA 0x{0:x}\'.format(self.rva_ptr))\nclass PEFormatError(Exception):\n    def __init__(self,value):self.value=value\n    def __str__(self):return repr(self.value)\nclass Dump:\n    def __init__(self):self.text=[]\n    def add_lines(self,txt,indent=0):\n        for line in txt:self.add_line(line,indent)\n    def add_line(self,txt,indent=0):self.add(txt+\'\\n\',indent)\n    def add(self,txt,indent=0):self.text.append(\'{0}{1}\'.format(\' \'*indent,txt))\n    def add_header(self,txt):self.add_line(\'{0}{1}{0}\\n\'.format(\'-\'*10,txt))\n    def add_newline(self):self.text.append(\'\\n\')\n    def get_text(self):return\'\'.join(\'{0}\'.format(b)for b in self.text)\nSTRUCT_SIZEOF_TYPES={\'x\':1,\'c\':1,\'b\':1,\'B\':1,\'h\':2,\'H\':2,\'i\':4,\'I\':4,\'l\':4,\'L\':4,\'f\':4,\'q\':8,\'Q\':8,\'d\':8,\'s\':1}\n@lru_cache(maxsize=2048)\ndef sizeof_type(t):\n    count=1;_t=t\n    if t[0]in string.digits:count=int(\'\'.join([d for d in t if d in string.digits]));_t=\'\'.join([d for d in t if d not in string.digits])\n    return STRUCT_SIZEOF_TYPES[_t]*count\n@lru_cache(maxsize=2048,copy=True)\ndef set_format(format):\n    __format_str__=\'<\';__unpacked_data_elms__=[];__field_offsets__={};__keys__=[];__format_length__=0;offset=0\n    for elm in format:\n        if\',\'in elm:\n            elm_type,elm_name=elm.split(\',\',1);__format_str__+=elm_type;__unpacked_data_elms__.append(None);elm_names=elm_name.split(\',\');names=[]\n            for elm_name in elm_names:\n                if elm_name in __keys__:search_list=[x[:len(elm_name)]for x in __keys__];occ_count=search_list.count(elm_name);elm_name=\'{0}_{1:d}\'.format(elm_name,occ_count)\n                names.append(elm_name);__field_offsets__[elm_name]=offset\n            offset+=sizeof_type(elm_type);__keys__.append(names)\n    __format_length__=struct.calcsize(__format_str__);return __format_str__,__unpacked_data_elms__,__field_offsets__,__keys__,__format_length__\nclass Structure:\n    def __init__(self,format,name=None,file_offset=None):\n        self.__format_str__=\'<\';self.__keys__=[];self.__format_length__=0;self.__field_offsets__={};self.__unpacked_data_elms__=[];d=format[1]\n        if not isinstance(d,tuple):d=tuple(d)\n        self.__format_str__,self.__unpacked_data_elms__,self.__field_offsets__,self.__keys__,self.__format_length__=set_format(d);self.__all_zeroes__=False;self.__file_offset__=file_offset\n        if name:self.name=name\n        else:self.name=format[0]\n    def __get_format__(self):return self.__format_str__\n    def get_field_absolute_offset(self,field_name):return self.__file_offset__+self.__field_offsets__[field_name]\n    def get_field_relative_offset(self,field_name):return self.__field_offsets__[field_name]\n    def get_file_offset(self):return self.__file_offset__\n    def set_file_offset(self,offset):self.__file_offset__=offset\n    def all_zeroes(self):return self.__all_zeroes__\n    def sizeof(self):return self.__format_length__\n    def __unpack__(self,data):\n        data=data\n        if len(data)>self.__format_length__:data=data[:self.__format_length__]\n        elif len(data)<self.__format_length__:raise PEFormatError(\'Data length less than expected header length.\')\n        if count_zeroes(data)==len(data):self.__all_zeroes__=True\n        self.__unpacked_data_elms__=struct.unpack(self.__format_str__,data)\n        for(idx,val)in enumerate(self.__unpacked_data_elms__):\n            for key in self.__keys__[idx]:setattr(self,key,val)\n    def __pack__(self):\n        new_values=[]\n        for(idx,val)in enumerate(self.__unpacked_data_elms__):\n            new_val=None\n            for key in self.__keys__[idx]:\n                new_val=getattr(self,key)\n                if new_val!=val:break\n            new_values.append(new_val)\n        return struct.pack(self.__format_str__,*new_values)\n    def __str__(self):return\'\\n\'.join(self.dump())\n    def __repr__(self):return\'<Structure: %s>\'%\' \'.join([\' \'.join(s.split())for s in self.dump()])\n    def dump(self,indentation=0):\n        dump=[];dump.append(\'[{0}]\'.format(self.name));printable_bytes=[ord(i)for i in string.printable if i not in string.whitespace]\n        for keys in self.__keys__:\n            for key in keys:\n                val=getattr(self,key)\n                if isinstance(val,(int,long)):\n                    if key.startswith(\'Signature_\'):val_str=\'{:<8X}\'.format(val)\n                    else:val_str=\'0x{:<8X}\'.format(val)\n                    if key==\'TimeDateStamp\'or key==\'dwTimeStamp\':\n                        try:val_str+=\' [%s UTC]\'%time.asctime(time.gmtime(val))\n                        except ValueError:val_str+=\' [INVALID TIME]\'\n                else:\n                    val_str=bytearray(val)\n                    if key.startswith(\'Signature\'):val_str=\'\'.join([\'{:02X}\'.format(i)for i in val_str.rstrip(b\'\\x00\')])\n                    else:val_str=\'\'.join([chr(i)if i in printable_bytes else\'\\\\x{0:02x}\'.format(i)for i in val_str.rstrip(b\'\\x00\')])\n                dump.append(\'0x%-8X 0x%-3X %-30s %s\'%(self.__field_offsets__[key]+self.__file_offset__,self.__field_offsets__[key],key+\':\',val_str))\n        return dump\n    def dump_dict(self):\n        dump_dict={};dump_dict[\'Structure\']=self.name\n        for keys in self.__keys__:\n            for key in keys:\n                val=getattr(self,key)\n                if isinstance(val,(int,long)):\n                    if key==\'TimeDateStamp\'or key==\'dwTimeStamp\':\n                        try:val=\'0x%-8X [%s UTC]\'%(val,time.asctime(time.gmtime(val)))\n                        except ValueError:val=\'0x%-8X [INVALID TIME]\'%val\n                else:val=\'\'.join(chr(d)if chr(d)in string.printable else\'\\\\x%02x\'%d for d in[ord(c)if not isinstance(c,int)else c for c in val])\n                dump_dict[key]={\'FileOffset\':self.__field_offsets__[key]+self.__file_offset__,\'Offset\':self.__field_offsets__[key],\'Value\':val}\n        return dump_dict\nclass SectionStructure(Structure):\n    def __init__(self,*args,**kwargs):\n        if\'pe\'in kwargs:self.pe=kwargs[\'pe\'];del kwargs[\'pe\']\n        self.PointerToRawData=None;self.VirtualAddress=None;self.SizeOfRawData=None;self.Misc_VirtualSize=None;super().__init__(*args,**kwargs);self.PointerToRawData_adj=None;self.VirtualAddress_adj=None;self.section_min_addr=None;self.section_max_addr=None\n    def get_PointerToRawData_adj(self):\n        if self.PointerToRawData_adj is None and self.PointerToRawData is not None:\n            ptrd=self.pe.adjust_PointerToRawData(self.PointerToRawData)\n            if self.pe.OPTIONAL_HEADER.SectionAlignment<4096:\n                if self.PointerToRawData==self.VirtualAddress:ptrd=self.VirtualAddress\n            self.PointerToRawData_adj=ptrd\n        return self.PointerToRawData_adj\n    def get_VirtualAddress_adj(self):\n        if self.VirtualAddress_adj is None:\n            if self.VirtualAddress is not None:self.VirtualAddress_adj=self.pe.adjust_SectionAlignment(self.VirtualAddress,self.pe.OPTIONAL_HEADER.SectionAlignment,self.pe.OPTIONAL_HEADER.FileAlignment)\n        return self.VirtualAddress_adj\n    def get_data(self,start=None,length=None,ignore_padding=False):\n        if start is None:offset=self.get_PointerToRawData_adj()\n        else:offset=start-self.get_VirtualAddress_adj()+self.get_PointerToRawData_adj()\n        if length is not None:end=offset+length\n        elif self.SizeOfRawData is not None:end=offset+self.SizeOfRawData\n        else:end=offset\n        if ignore_padding and end is not None and offset is not None:end=min(end,offset+self.Misc_VirtualSize)\n        if self.PointerToRawData is not None and self.SizeOfRawData is not None:\n            if end>self.PointerToRawData+self.SizeOfRawData:end=self.PointerToRawData+self.SizeOfRawData\n        return self.pe.__data__[offset:end]\n    def __setattr__(self,name,val):\n        if name==\'Characteristics\':section_flags=retrieve_flags(SECTION_CHARACTERISTICS,\'IMAGE_SCN_\');set_flags(self,val,section_flags)\n        elif\'IMAGE_SCN_\'in name and hasattr(self,name):\n            if val:self.__dict__[\'Characteristics\']|=SECTION_CHARACTERISTICS[name]\n            else:self.__dict__[\'Characteristics\']^=SECTION_CHARACTERISTICS[name]\n        self.__dict__[name]=val\n    def get_rva_from_offset(self,offset):return offset-self.get_PointerToRawData_adj()+self.get_VirtualAddress_adj()\n    def get_offset_from_rva(self,rva):return rva-self.get_VirtualAddress_adj()+self.get_PointerToRawData_adj()\n    def contains_offset(self,offset):\n        if self.PointerToRawData is None:return False\n        PointerToRawData_adj=self.get_PointerToRawData_adj();return PointerToRawData_adj<=offset<PointerToRawData_adj+self.SizeOfRawData\n    def contains_rva(self,rva):\n        if self.section_min_addr is not None and self.section_max_addr is not None:return self.section_min_addr<=rva<self.section_max_addr\n        VirtualAddress_adj=self.get_VirtualAddress_adj()\n        if len(self.pe.__data__)-self.get_PointerToRawData_adj()<self.SizeOfRawData:size=self.Misc_VirtualSize\n        else:size=max(self.SizeOfRawData,self.Misc_VirtualSize)\n        if self.next_section_virtual_address is not None and self.next_section_virtual_address>self.VirtualAddress and VirtualAddress_adj+size>self.next_section_virtual_address:size=self.next_section_virtual_address-VirtualAddress_adj\n        self.section_min_addr=VirtualAddress_adj;self.section_max_addr=VirtualAddress_adj+size;return VirtualAddress_adj<=rva<VirtualAddress_adj+size\n    def contains(self,rva):return self.contains_rva(rva)\n    def get_entropy(self):return self.entropy_H(self.get_data())\n    def get_hash_sha1(self):\n        if sha1 is not None:return sha1(self.get_data()).hexdigest()\n    def get_hash_sha256(self):\n        if sha256 is not None:return sha256(self.get_data()).hexdigest()\n    def get_hash_sha512(self):\n        if sha512 is not None:return sha512(self.get_data()).hexdigest()\n    def get_hash_md5(self):\n        if md5 is not None:return md5(self.get_data()).hexdigest()\n    def entropy_H(self,data):\n        if not data:return .0\n        occurences=Counter(bytearray(data));entropy=0\n        for x in occurences.values():p_x=float(x)/len(data);entropy-=p_x*math.log(p_x,2)\n        return entropy\n@lru_cache(maxsize=2048,copy=False)\ndef set_bitfields_format(format):\n    class Accumulator:\n        def __init__(self,fmt,comp_fields):self._subfields=[];self._name=\'~\';self._type=None;self._bits_left=0;self._comp_fields=comp_fields;self._format=fmt\n        def wrap_up(self):\n            if self._type is None:return\n            self._format.append(self._type+\',\'+self._name);self._comp_fields[len(self._format)-1]=self._type,self._subfields;self._name=\'~\';self._type=None;self._subfields=[]\n        def new_type(self,tp):self._bits_left=STRUCT_SIZEOF_TYPES[tp]*8;self._type=tp\n        def add_subfield(self,name,bitcnt):self._name+=name;self._bits_left-=bitcnt;self._subfields.append((name,bitcnt))\n        def get_type(self):return self._type\n        def get_name(self):return self._name\n        def get_bits_left(self):return self._bits_left\n    old_fmt=[];comp_fields={};ac=Accumulator(old_fmt,comp_fields)\n    for elm in format[1]:\n        if\':\'not in elm:ac.wrap_up();old_fmt.append(elm);continue\n        elm_type,elm_name=elm.split(\',\',1)\n        if\',\'in elm_name:raise NotImplementedError(\'Structures with bitfields do not support unions yet\')\n        elm_type,elm_bits=elm_type.split(\':\',1);elm_bits=int(elm_bits)\n        if elm_type!=ac.get_type()or elm_bits>ac.get_bits_left():ac.wrap_up();ac.new_type(elm_type)\n        ac.add_subfield(elm_name,elm_bits)\n    ac.wrap_up();format_str,_,field_offsets,keys,format_length=set_format(tuple(old_fmt));extended_keys=[]\n    for(idx,val)in enumerate(keys):\n        if idx not in comp_fields:extended_keys.append(val);continue\n        _,sbf=comp_fields[idx];bf_names=[[f[StructureWithBitfields.BTF_NAME_IDX]]for f in sbf];extended_keys.extend(bf_names)\n        for n in bf_names:field_offsets[n[0]]=field_offsets[val[0]]\n    return format_str,format_length,field_offsets,keys,extended_keys,comp_fields\nclass StructureWithBitfields(Structure):\n    BTF_NAME_IDX=0;BTF_BITCNT_IDX=1;CF_TYPE_IDX=0;CF_SUBFLD_IDX=1\n    def __init__(self,format,name=None,file_offset=None):self.__format_str__,self.__format_length__,self.__field_offsets__,self.__keys__,self.__keys_ext__,self.__compound_fields__=set_bitfields_format(format);self.__unpacked_data_elms__=[None for i in range(self.__format_length__)];self.__all_zeroes__=False;self.__file_offset__=file_offset;self.name=name if name!=None else format[0]\n    def __unpack__(self,data):super().__unpack__(data);self._unpack_bitfield_attributes()\n    def __pack__(self):\n        self._pack_bitfield_attributes()\n        try:data=super().__pack__()\n        finally:self._unpack_bitfield_attributes()\n        return data\n    def dump(self,indentation=0):\n        tk=self.__keys__;self.__keys__=self.__keys_ext__\n        try:ret=super().dump(indentation)\n        finally:self.__keys__=tk\n        return ret\n    def dump_dict(self):\n        tk=self.__keys__;self.__keys__=self.__keys_ext__\n        try:ret=super().dump_dict()\n        finally:self.__keys__=tk\n        return ret\n    def _unpack_bitfield_attributes(self):\n        for i in self.__compound_fields__.keys():\n            cf_name=self.__keys__[i][0];cval=getattr(self,cf_name);delattr(self,cf_name);offst=0\n            for sf in self.__compound_fields__[i][StructureWithBitfields.CF_SUBFLD_IDX]:mask=(1<<sf[StructureWithBitfields.BTF_BITCNT_IDX])-1;mask<<=offst;setattr(self,sf[StructureWithBitfields.BTF_NAME_IDX],(cval&mask)>>offst);offst+=sf[StructureWithBitfields.BTF_BITCNT_IDX]\n    def _pack_bitfield_attributes(self):\n        for i in self.__compound_fields__.keys():\n            cf_name=self.__keys__[i][0];offst,acc_val=0,0\n            for sf in self.__compound_fields__[i][StructureWithBitfields.CF_SUBFLD_IDX]:mask=(1<<sf[StructureWithBitfields.BTF_BITCNT_IDX])-1;field_val=getattr(self,sf[StructureWithBitfields.BTF_NAME_IDX])&mask;acc_val|=field_val<<offst;offst+=sf[StructureWithBitfields.BTF_BITCNT_IDX]\n            setattr(self,cf_name,acc_val)\nclass DataContainer:\n    def __init__(self,**kwargs):\n        bare_setattr=super().__setattr__\n        for(key,value)in kwargs.items():bare_setattr(key,value)\nclass ImportDescData(DataContainer):0\nclass ImportData(DataContainer):\n    def __setattr__(self,name,val):\n        if hasattr(self,\'ordinal\')and hasattr(self,\'bound\')and hasattr(self,\'name\'):\n            if name==\'ordinal\':\n                if self.pe.PE_TYPE==OPTIONAL_HEADER_MAGIC_PE:ordinal_flag=IMAGE_ORDINAL_FLAG\n                elif self.pe.PE_TYPE==OPTIONAL_HEADER_MAGIC_PE_PLUS:ordinal_flag=IMAGE_ORDINAL_FLAG64\n                self.struct_table.Ordinal=ordinal_flag|val&65535;self.struct_table.AddressOfData=self.struct_table.Ordinal;self.struct_table.Function=self.struct_table.Ordinal;self.struct_table.ForwarderString=self.struct_table.Ordinal\n            elif name==\'bound\':\n                if self.struct_iat is not None:self.struct_iat.AddressOfData=val;self.struct_iat.AddressOfData=self.struct_iat.AddressOfData;self.struct_iat.Function=self.struct_iat.AddressOfData;self.struct_iat.ForwarderString=self.struct_iat.AddressOfData\n            elif name==\'address\':self.struct_table.AddressOfData=val;self.struct_table.Ordinal=self.struct_table.AddressOfData;self.struct_table.Function=self.struct_table.AddressOfData;self.struct_table.ForwarderString=self.struct_table.AddressOfData\n            elif name==\'name\':\n                if self.name_offset:\n                    name_rva=self.pe.get_rva_from_offset(self.name_offset);self.pe.set_dword_at_offset(self.ordinal_offset,0|name_rva)\n                    if len(val)>len(self.name):raise PEFormatError(\'The export name provided is longer than the existing one.\')\n                    self.pe.set_bytes_at_offset(self.name_offset,val)\n        self.__dict__[name]=val\nclass ExportDirData(DataContainer):0\nclass ExportData(DataContainer):\n    def __setattr__(self,name,val):\n        if hasattr(self,\'ordinal\')and hasattr(self,\'address\')and hasattr(self,\'forwarder\')and hasattr(self,\'name\'):\n            if name==\'ordinal\':self.pe.set_word_at_offset(self.ordinal_offset,val)\n            elif name==\'address\':self.pe.set_dword_at_offset(self.address_offset,val)\n            elif name==\'name\':\n                if len(val)>len(self.name):raise PEFormatError(\'The export name provided is longer than the existing one.\')\n                self.pe.set_bytes_at_offset(self.name_offset,val)\n            elif name==\'forwarder\':\n                if len(val)>len(self.forwarder):raise PEFormatError(\'The forwarder name provided is longer than the existing one.\')\n                self.pe.set_bytes_at_offset(self.forwarder_offset,val)\n        self.__dict__[name]=val\nclass ResourceDirData(DataContainer):0\nclass ResourceDirEntryData(DataContainer):0\nclass ResourceDataEntryData(DataContainer):0\nclass DebugData(DataContainer):0\nclass DynamicRelocationData(DataContainer):0\nclass FunctionOverrideData(DataContainer):0\nclass FunctionOverrideDynamicRelocationData(DataContainer):0\nclass BddDynamicRelocationData(DataContainer):0\nclass BaseRelocationData(DataContainer):0\nclass RelocationData(DataContainer):\n    def __setattr__(self,name,val):\n        if hasattr(self,\'struct\'):\n            word=self.struct.Data\n            if name==\'type\':word=val<<12|word&4095\n            elif name==\'rva\':offset=max(val-self.base_rva,0);word=word&61440|offset&4095\n            self.struct.Data=word\n        self.__dict__[name]=val\nclass TlsData(DataContainer):0\nclass BoundImportDescData(DataContainer):0\nclass LoadConfigData(DataContainer):0\nclass BoundImportRefData(DataContainer):0\nclass ExceptionsDirEntryData(DataContainer):0\nclass UnwindInfo(StructureWithBitfields):\n    def __init__(self,file_offset=0):super().__init__((\'UNWIND_INFO\',(\'B:3,Version\',\'B:5,Flags\',\'B,SizeOfProlog\',\'B,CountOfCodes\',\'B:4,FrameRegister\',\'B:4,FrameOffset\')),file_offset=file_offset);self._full_size=super().sizeof();self._opt_field_name=None;self._code_info=StructureWithBitfields((\'UNWIND_CODE\',(\'B,CodeOffset\',\'B:4,UnwindOp\',\'B:4,OpInfo\')),file_offset=0);self._chained_entry=None;self._finished_unpacking=False\n    def unpack_in_stages(self,data):\n        if self._finished_unpacking:return\n        super().__unpack__(data);codes_cnt_max=self.CountOfCodes+1&~1;hdlr_offset=super().sizeof()+codes_cnt_max*self._code_info.sizeof();self._full_size=hdlr_offset+(0 if self.Flags==0 else STRUCT_SIZEOF_TYPES[\'I\'])\n        if len(data)<self._full_size:return\n        if self.Version!=1 and self.Version!=2:return\'Unsupported version of UNWIND_INFO at \'+hex(self.__file_offset__)\n        self.UnwindCodes=[];ro=super().sizeof();codes_left=self.CountOfCodes\n        while codes_left>0:\n            self._code_info.__unpack__(data[ro:ro+self._code_info.sizeof()]);ucode=PrologEpilogOpsFactory.create(self._code_info)\n            if ucode is None:return\'Unknown UNWIND_CODE at \'+hex(self.__file_offset__+ro)\n            len_in_codes=ucode.length_in_code_structures(self._code_info,self);opc_size=self._code_info.sizeof()*len_in_codes;ucode.initialize(self._code_info,data[ro:ro+opc_size],self,self.__file_offset__+ro);ro+=opc_size;codes_left-=len_in_codes;self.UnwindCodes.append(ucode)\n        if self.UNW_FLAG_EHANDLER or self.UNW_FLAG_UHANDLER:self._opt_field_name=\'ExceptionHandler\'\n        if self.UNW_FLAG_CHAININFO:self._opt_field_name=\'FunctionEntry\'\n        if self._opt_field_name!=None:setattr(self,self._opt_field_name,struct.unpack(\'<I\',data[hdlr_offset:hdlr_offset+STRUCT_SIZEOF_TYPES[\'I\']])[0])\n        self._finished_unpacking=True\n    def dump(self,indentation=0):\n        if self._opt_field_name!=None:self.__field_offsets__[self._opt_field_name]=self._full_size-STRUCT_SIZEOF_TYPES[\'I\'];self.__keys_ext__.append([self._opt_field_name])\n        try:dump=super().dump(indentation)\n        finally:\n            if self._opt_field_name!=None:self.__keys_ext__.pop()\n        dump.append(\'Flags: \'+\', \'.join([s[0]for s in unwind_info_flags if getattr(self,s[0])]));dump.append(\'Unwind codes: \'+\'; \'.join([str(c)for c in self.UnwindCodes if c.is_valid()]));return dump\n    def dump_dict(self):\n        if self._opt_field_name!=None:self.__field_offsets__[self._opt_field_name]=self._full_size-STRUCT_SIZEOF_TYPES[\'I\'];self.__keys_ext__.append([self._opt_field_name])\n        try:ret=super().dump_dict()\n        finally:\n            if self._opt_field_name!=None:self.__keys_ext__.pop()\n        return ret\n    def __setattr__(self,name,val):\n        if name==\'Flags\':set_flags(self,val,unwind_info_flags)\n        elif\'UNW_FLAG_\'in name and hasattr(self,name):\n            if val:self.__dict__[\'Flags\']|=UNWIND_INFO_FLAGS[name]\n            else:self.__dict__[\'Flags\']^=UNWIND_INFO_FLAGS[name]\n        self.__dict__[name]=val\n    def sizeof(self):return self._full_size\n    def __pack__(self):\n        data=bytearray(self._full_size);data[0:super().sizeof()]=super().__pack__();cur_offset=super().sizeof()\n        for uc in self.UnwindCodes:\n            if cur_offset+uc.struct.sizeof()>self._full_size:break\n            data[cur_offset:cur_offset+uc.struct.sizeof()]=uc.struct.__pack__();cur_offset+=uc.struct.sizeof()\n        if self._opt_field_name!=None:data[self._full_size-STRUCT_SIZEOF_TYPES[\'I\']:self._full_size]=struct.pack(\'<I\',getattr(self,self._opt_field_name))\n        return data\n    def get_chained_function_entry(self):return self._chained_entry\n    def set_chained_function_entry(self,entry):\n        if self._chained_entry!=None:raise PEFormatError(\'Chained function entry cannot be changed\')\n        self._chained_entry=entry\nclass PrologEpilogOp:\n    def initialize(self,unw_code,data,unw_info,file_offset):self.struct=StructureWithBitfields(self._get_format(unw_code),file_offset=file_offset);self.struct.__unpack__(data)\n    def length_in_code_structures(self,unw_code,unw_info):return 1\n    def is_valid(self):return True\n    def _get_format(self,unw_code):return\'UNWIND_CODE\',(\'B,CodeOffset\',\'B:4,UnwindOp\',\'B:4,OpInfo\')\nclass PrologEpilogOpPushReg(PrologEpilogOp):\n    def _get_format(self,unw_code):return\'UNWIND_CODE_PUSH_NONVOL\',(\'B,CodeOffset\',\'B:4,UnwindOp\',\'B:4,Reg\')\n    def __str__(self):return\'.PUSHREG \'+REGISTERS[self.struct.Reg]\nclass PrologEpilogOpAllocLarge(PrologEpilogOp):\n    def _get_format(self,unw_code):return\'UNWIND_CODE_ALLOC_LARGE\',(\'B,CodeOffset\',\'B:4,UnwindOp\',\'B:4,OpInfo\',\'H,AllocSizeInQwords\'if unw_code.OpInfo==0 else\'I,AllocSize\')\n    def length_in_code_structures(self,unw_code,unw_info):return 2 if unw_code.OpInfo==0 else 3\n    def get_alloc_size(self):return self.struct.AllocSizeInQwords*8 if self.struct.OpInfo==0 else self.struct.AllocSize\n    def __str__(self):return\'.ALLOCSTACK \'+hex(self.get_alloc_size())\nclass PrologEpilogOpAllocSmall(PrologEpilogOp):\n    def _get_format(self,unw_code):return\'UNWIND_CODE_ALLOC_SMALL\',(\'B,CodeOffset\',\'B:4,UnwindOp\',\'B:4,AllocSizeInQwordsMinus8\')\n    def get_alloc_size(self):return self.struct.AllocSizeInQwordsMinus8*8+8\n    def __str__(self):return\'.ALLOCSTACK \'+hex(self.get_alloc_size())\nclass PrologEpilogOpSetFP(PrologEpilogOp):\n    def initialize(self,unw_code,data,unw_info,file_offset):super().initialize(unw_code,data,unw_info,file_offset);self._frame_register=unw_info.FrameRegister;self._frame_offset=unw_info.FrameOffset*16\n    def __str__(self):return\'.SETFRAME \'+REGISTERS[self._frame_register]+\', \'+hex(self._frame_offset)\nclass PrologEpilogOpSaveReg(PrologEpilogOp):\n    def length_in_code_structures(self,unwcode,unw_info):return 2\n    def get_offset(self):return self.struct.OffsetInQwords*8\n    def _get_format(self,unw_code):return\'UNWIND_CODE_SAVE_NONVOL\',(\'B,CodeOffset\',\'B:4,UnwindOp\',\'B:4,Reg\',\'H,OffsetInQwords\')\n    def __str__(self):return\'.SAVEREG \'+REGISTERS[self.struct.Reg]+\', \'+hex(self.get_offset())\nclass PrologEpilogOpSaveRegFar(PrologEpilogOp):\n    def length_in_code_structures(self,unw_code,unw_info):return 3\n    def get_offset(self):return self.struct.Offset\n    def _get_format(self,unw_code):return\'UNWIND_CODE_SAVE_NONVOL_FAR\',(\'B,CodeOffset\',\'B:4,UnwindOp\',\'B:4,Reg\',\'I,Offset\')\n    def __str__(self):return\'.SAVEREG \'+REGISTERS[self.struct.Reg]+\', \'+hex(self.struct.Offset)\nclass PrologEpilogOpSaveXMM(PrologEpilogOp):\n    def _get_format(self,unw_code):return\'UNWIND_CODE_SAVE_XMM128\',(\'B,CodeOffset\',\'B:4,UnwindOp\',\'B:4,Reg\',\'H,OffsetIn2Qwords\')\n    def length_in_code_structures(self,unw_code,unw_info):return 2\n    def get_offset(self):return self.struct.OffsetIn2Qwords*16\n    def __str__(self):return\'.SAVEXMM128 XMM\'+str(self.struct.Reg)+\', \'+hex(self.get_offset())\nclass PrologEpilogOpSaveXMMFar(PrologEpilogOp):\n    def _get_format(self,unw_code):return\'UNWIND_CODE_SAVE_XMM128_FAR\',(\'B,CodeOffset\',\'B:4,UnwindOp\',\'B:4,Reg\',\'I,Offset\')\n    def length_in_code_structures(self,unw_code,unw_info):return 3\n    def get_offset(self):return self.struct.Offset\n    def __str__(self):return\'.SAVEXMM128 XMM\'+str(self.struct.Reg)+\', \'+hex(self.struct.Offset)\nclass PrologEpilogOpPushFrame(PrologEpilogOp):\n    def __str__(self):return\'.PUSHFRAME\'+(\' <code>\'if self.struct.OpInfo else\'\')\nclass PrologEpilogOpEpilogMarker(PrologEpilogOp):\n    def initialize(self,unw_code,data,unw_info,file_offset):\n        self._long_offst=True;self._first=not hasattr(unw_info,\'SizeOfEpilog\');super().initialize(unw_code,data,unw_info,file_offset)\n        if self._first:setattr(unw_info,\'SizeOfEpilog\',self.struct.Size);self._long_offst=unw_code.OpInfo&1==0\n        self._epilog_size=unw_info.SizeOfEpilog\n    def _get_format(self,unw_code):\n        if self._first:return\'UNWIND_CODE_EPILOG\',(\'B,OffsetLow,Size\',\'B:4,UnwindOp\',\'B:4,Flags\')if unw_code.OpInfo&1==1 else(\'B,Size\',\'B:4,UnwindOp\',\'B:4,Flags\',\'B,OffsetLow\',\'B:4,Unused\',\'B:4,OffsetHigh\')\n        else:return\'UNWIND_CODE_EPILOG\',(\'B,OffsetLow\',\'B:4,UnwindOp\',\'B:4,OffsetHigh\')\n    def length_in_code_structures(self,unw_code,unw_info):return 2 if not hasattr(unw_info,\'SizeOfEpilog\')and unw_code.OpInfo&1==0 else 1\n    def get_offset(self):return self.struct.OffsetLow|(self.struct.OffsetHigh<<8 if self._long_offst else 0)\n    def is_valid(self):return self.get_offset()>0\n    def __str__(self):return\'EPILOG: size=\'+hex(self._epilog_size)+\', offset from the end=-\'+hex(self.get_offset())if self.get_offset()>0 else\'\'\nclass PrologEpilogOpsFactory:\n    _class_dict={UWOP_PUSH_NONVOL:PrologEpilogOpPushReg,UWOP_ALLOC_LARGE:PrologEpilogOpAllocLarge,UWOP_ALLOC_SMALL:PrologEpilogOpAllocSmall,UWOP_SET_FPREG:PrologEpilogOpSetFP,UWOP_SAVE_NONVOL:PrologEpilogOpSaveReg,UWOP_SAVE_NONVOL_FAR:PrologEpilogOpSaveRegFar,UWOP_SAVE_XMM128:PrologEpilogOpSaveXMM,UWOP_SAVE_XMM128_FAR:PrologEpilogOpSaveXMMFar,UWOP_PUSH_MACHFRAME:PrologEpilogOpPushFrame,UWOP_EPILOG:PrologEpilogOpEpilogMarker}\n    @staticmethod\n    def create(unwcode):code=unwcode.UnwindOp;return PrologEpilogOpsFactory._class_dict[code]()if code in PrologEpilogOpsFactory._class_dict else None\nallowed_filename=(string.ascii_lowercase+string.ascii_uppercase+string.digits+"!#$%&\'()-@^_`{}~+,.;=[]:").encode()\ndef is_valid_dos_filename(s):\n    if s is None or not isinstance(s,(str,bytes,bytearray)):return False\n    allowed=allowed_filename+b\'\\\\/\';return all(c in allowed for c in set(s))\nallowed_function_name=(string.ascii_lowercase+string.ascii_uppercase+string.digits).encode()\n@lru_cache(maxsize=2048)\ndef is_valid_function_name(s,relax_allowed_characters=False):\n    allowed_extra=b\'._?@$()<>\'\n    if relax_allowed_characters:allowed_extra=b\'!"#$%&\\\'()*+,-./:<>?[\\\\]^_`{|}~@\'\n    return s is not None and isinstance(s,(str,bytes,bytearray))and all(c in allowed_function_name or c in allowed_extra for c in set(s))\nclass PE:\n    __IMAGE_DOS_HEADER_format__=\'IMAGE_DOS_HEADER\',(\'H,e_magic\',\'H,e_cblp\',\'H,e_cp\',\'H,e_crlc\',\'H,e_cparhdr\',\'H,e_minalloc\',\'H,e_maxalloc\',\'H,e_ss\',\'H,e_sp\',\'H,e_csum\',\'H,e_ip\',\'H,e_cs\',\'H,e_lfarlc\',\'H,e_ovno\',\'8s,e_res\',\'H,e_oemid\',\'H,e_oeminfo\',\'20s,e_res2\',\'I,e_lfanew\');__IMAGE_FILE_HEADER_format__=\'IMAGE_FILE_HEADER\',(\'H,Machine\',\'H,NumberOfSections\',\'I,TimeDateStamp\',\'I,PointerToSymbolTable\',\'I,NumberOfSymbols\',\'H,SizeOfOptionalHeader\',\'H,Characteristics\');__IMAGE_DATA_DIRECTORY_format__=\'IMAGE_DATA_DIRECTORY\',(\'I,VirtualAddress\',\'I,Size\');__IMAGE_OPTIONAL_HEADER_format__=\'IMAGE_OPTIONAL_HEADER\',(\'H,Magic\',\'B,MajorLinkerVersion\',\'B,MinorLinkerVersion\',\'I,SizeOfCode\',\'I,SizeOfInitializedData\',\'I,SizeOfUninitializedData\',\'I,AddressOfEntryPoint\',\'I,BaseOfCode\',\'I,BaseOfData\',\'I,ImageBase\',\'I,SectionAlignment\',\'I,FileAlignment\',\'H,MajorOperatingSystemVersion\',\'H,MinorOperatingSystemVersion\',\'H,MajorImageVersion\',\'H,MinorImageVersion\',\'H,MajorSubsystemVersion\',\'H,MinorSubsystemVersion\',\'I,Reserved1\',\'I,SizeOfImage\',\'I,SizeOfHeaders\',\'I,CheckSum\',\'H,Subsystem\',\'H,DllCharacteristics\',\'I,SizeOfStackReserve\',\'I,SizeOfStackCommit\',\'I,SizeOfHeapReserve\',\'I,SizeOfHeapCommit\',\'I,LoaderFlags\',\'I,NumberOfRvaAndSizes\');__IMAGE_OPTIONAL_HEADER64_format__=\'IMAGE_OPTIONAL_HEADER64\',(\'H,Magic\',\'B,MajorLinkerVersion\',\'B,MinorLinkerVersion\',\'I,SizeOfCode\',\'I,SizeOfInitializedData\',\'I,SizeOfUninitializedData\',\'I,AddressOfEntryPoint\',\'I,BaseOfCode\',\'Q,ImageBase\',\'I,SectionAlignment\',\'I,FileAlignment\',\'H,MajorOperatingSystemVersion\',\'H,MinorOperatingSystemVersion\',\'H,MajorImageVersion\',\'H,MinorImageVersion\',\'H,MajorSubsystemVersion\',\'H,MinorSubsystemVersion\',\'I,Reserved1\',\'I,SizeOfImage\',\'I,SizeOfHeaders\',\'I,CheckSum\',\'H,Subsystem\',\'H,DllCharacteristics\',\'Q,SizeOfStackReserve\',\'Q,SizeOfStackCommit\',\'Q,SizeOfHeapReserve\',\'Q,SizeOfHeapCommit\',\'I,LoaderFlags\',\'I,NumberOfRvaAndSizes\');__IMAGE_NT_HEADERS_format__=\'IMAGE_NT_HEADERS\',(\'I,Signature\',);__IMAGE_SECTION_HEADER_format__=\'IMAGE_SECTION_HEADER\',(\'8s,Name\',\'I,Misc,Misc_PhysicalAddress,Misc_VirtualSize\',\'I,VirtualAddress\',\'I,SizeOfRawData\',\'I,PointerToRawData\',\'I,PointerToRelocations\',\'I,PointerToLinenumbers\',\'H,NumberOfRelocations\',\'H,NumberOfLinenumbers\',\'I,Characteristics\');__IMAGE_DELAY_IMPORT_DESCRIPTOR_format__=\'IMAGE_DELAY_IMPORT_DESCRIPTOR\',(\'I,grAttrs\',\'I,szName\',\'I,phmod\',\'I,pIAT\',\'I,pINT\',\'I,pBoundIAT\',\'I,pUnloadIAT\',\'I,dwTimeStamp\');__IMAGE_IMPORT_DESCRIPTOR_format__=\'IMAGE_IMPORT_DESCRIPTOR\',(\'I,OriginalFirstThunk,Characteristics\',\'I,TimeDateStamp\',\'I,ForwarderChain\',\'I,Name\',\'I,FirstThunk\');__IMAGE_EXPORT_DIRECTORY_format__=\'IMAGE_EXPORT_DIRECTORY\',(\'I,Characteristics\',\'I,TimeDateStamp\',\'H,MajorVersion\',\'H,MinorVersion\',\'I,Name\',\'I,Base\',\'I,NumberOfFunctions\',\'I,NumberOfNames\',\'I,AddressOfFunctions\',\'I,AddressOfNames\',\'I,AddressOfNameOrdinals\');__IMAGE_RESOURCE_DIRECTORY_format__=\'IMAGE_RESOURCE_DIRECTORY\',(\'I,Characteristics\',\'I,TimeDateStamp\',\'H,MajorVersion\',\'H,MinorVersion\',\'H,NumberOfNamedEntries\',\'H,NumberOfIdEntries\');__IMAGE_RESOURCE_DIRECTORY_ENTRY_format__=\'IMAGE_RESOURCE_DIRECTORY_ENTRY\',(\'I,Name\',\'I,OffsetToData\');__IMAGE_RESOURCE_DATA_ENTRY_format__=\'IMAGE_RESOURCE_DATA_ENTRY\',(\'I,OffsetToData\',\'I,Size\',\'I,CodePage\',\'I,Reserved\');__VS_VERSIONINFO_format__=\'VS_VERSIONINFO\',(\'H,Length\',\'H,ValueLength\',\'H,Type\');__VS_FIXEDFILEINFO_format__=\'VS_FIXEDFILEINFO\',(\'I,Signature\',\'I,StrucVersion\',\'I,FileVersionMS\',\'I,FileVersionLS\',\'I,ProductVersionMS\',\'I,ProductVersionLS\',\'I,FileFlagsMask\',\'I,FileFlags\',\'I,FileOS\',\'I,FileType\',\'I,FileSubtype\',\'I,FileDateMS\',\'I,FileDateLS\');__StringFileInfo_format__=\'StringFileInfo\',(\'H,Length\',\'H,ValueLength\',\'H,Type\');__StringTable_format__=\'StringTable\',(\'H,Length\',\'H,ValueLength\',\'H,Type\');__String_format__=\'String\',(\'H,Length\',\'H,ValueLength\',\'H,Type\');__Var_format__=\'Var\',(\'H,Length\',\'H,ValueLength\',\'H,Type\');__IMAGE_THUNK_DATA_format__=\'IMAGE_THUNK_DATA\',(\'I,ForwarderString,Function,Ordinal,AddressOfData\',);__IMAGE_THUNK_DATA64_format__=\'IMAGE_THUNK_DATA\',(\'Q,ForwarderString,Function,Ordinal,AddressOfData\',);__IMAGE_DEBUG_DIRECTORY_format__=\'IMAGE_DEBUG_DIRECTORY\',(\'I,Characteristics\',\'I,TimeDateStamp\',\'H,MajorVersion\',\'H,MinorVersion\',\'I,Type\',\'I,SizeOfData\',\'I,AddressOfRawData\',\'I,PointerToRawData\');__IMAGE_BASE_RELOCATION_format__=\'IMAGE_BASE_RELOCATION\',(\'I,VirtualAddress\',\'I,SizeOfBlock\');__IMAGE_BASE_RELOCATION_ENTRY_format__=\'IMAGE_BASE_RELOCATION_ENTRY\',(\'H,Data\',);__IMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION_format__=\'IMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION\',(\'I:12,PageRelativeOffset\',\'I:1,IndirectCall\',\'I:19,IATIndex\');__IMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION_format__=\'IMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION\',(\'H:12,PageRelativeOffset\',\'H:1,IndirectCall\',\'H:1,RexWPrefix\',\'H:1,CfgCheck\',\'H:1,Reserved\');__IMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION_format__=\'IMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION\',(\'H:12,PageRelativeOffset\',\'H:4,RegisterNumber\');__IMAGE_FUNCTION_OVERRIDE_HEADER_format__=\'IMAGE_FUNCTION_OVERRIDE_HEADER\',(\'I,FuncOverrideSize\',);__IMAGE_FUNCTION_OVERRIDE_DYNAMIC_RELOCATION_format__=\'IMAGE_FUNCTION_OVERRIDE_DYNAMIC_RELOCATION\',(\'I,OriginalRva\',\'I,BDDOffset\',\'I,RvaSize\',\'I,BaseRelocSize\');__IMAGE_BDD_INFO_format__=\'IMAGE_BDD_INFO\',(\'I,Version\',\'I,BDDSize\');__IMAGE_BDD_DYNAMIC_RELOCATION_format__=\'IMAGE_BDD_DYNAMIC_RELOCATION\',(\'H,Left\',\'H,Right\',\'I,Value\');__IMAGE_TLS_DIRECTORY_format__=\'IMAGE_TLS_DIRECTORY\',(\'I,StartAddressOfRawData\',\'I,EndAddressOfRawData\',\'I,AddressOfIndex\',\'I,AddressOfCallBacks\',\'I,SizeOfZeroFill\',\'I,Characteristics\');__IMAGE_TLS_DIRECTORY64_format__=\'IMAGE_TLS_DIRECTORY\',(\'Q,StartAddressOfRawData\',\'Q,EndAddressOfRawData\',\'Q,AddressOfIndex\',\'Q,AddressOfCallBacks\',\'I,SizeOfZeroFill\',\'I,Characteristics\');__IMAGE_LOAD_CONFIG_DIRECTORY_format__=\'IMAGE_LOAD_CONFIG_DIRECTORY\',(\'I,Size\',\'I,TimeDateStamp\',\'H,MajorVersion\',\'H,MinorVersion\',\'I,GlobalFlagsClear\',\'I,GlobalFlagsSet\',\'I,CriticalSectionDefaultTimeout\',\'I,DeCommitFreeBlockThreshold\',\'I,DeCommitTotalFreeThreshold\',\'I,LockPrefixTable\',\'I,MaximumAllocationSize\',\'I,VirtualMemoryThreshold\',\'I,ProcessHeapFlags\',\'I,ProcessAffinityMask\',\'H,CSDVersion\',\'H,DependentLoadFlags\',\'I,EditList\',\'I,SecurityCookie\',\'I,SEHandlerTable\',\'I,SEHandlerCount\',\'I,GuardCFCheckFunctionPointer\',\'I,GuardCFDispatchFunctionPointer\',\'I,GuardCFFunctionTable\',\'I,GuardCFFunctionCount\',\'I,GuardFlags\',\'H,CodeIntegrityFlags\',\'H,CodeIntegrityCatalog\',\'I,CodeIntegrityCatalogOffset\',\'I,CodeIntegrityReserved\',\'I,GuardAddressTakenIatEntryTable\',\'I,GuardAddressTakenIatEntryCount\',\'I,GuardLongJumpTargetTable\',\'I,GuardLongJumpTargetCount\',\'I,DynamicValueRelocTable\',\'I,CHPEMetadataPointer\',\'I,GuardRFFailureRoutine\',\'I,GuardRFFailureRoutineFunctionPointer\',\'I,DynamicValueRelocTableOffset\',\'H,DynamicValueRelocTableSection\',\'H,Reserved2\',\'I,GuardRFVerifyStackPointerFunctionPointer\',\'I,HotPatchTableOffset\',\'I,Reserved3\',\'I,EnclaveConfigurationPointer\',\'I,VolatileMetadataPointer\',\'I,GuardEHContinuationTable\',\'I,GuardEHContinuationCount\',\'I,GuardXFGCheckFunctionPointer\',\'I,GuardXFGDispatchFunctionPointer\',\'I,GuardXFGTableDispatchFunctionPointer\',\'I,CastGuardOsDeterminedFailureMode\',\'I,GuardMemcpyFunctionPointer\');__IMAGE_LOAD_CONFIG_DIRECTORY64_format__=\'IMAGE_LOAD_CONFIG_DIRECTORY\',(\'I,Size\',\'I,TimeDateStamp\',\'H,MajorVersion\',\'H,MinorVersion\',\'I,GlobalFlagsClear\',\'I,GlobalFlagsSet\',\'I,CriticalSectionDefaultTimeout\',\'Q,DeCommitFreeBlockThreshold\',\'Q,DeCommitTotalFreeThreshold\',\'Q,LockPrefixTable\',\'Q,MaximumAllocationSize\',\'Q,VirtualMemoryThreshold\',\'Q,ProcessAffinityMask\',\'I,ProcessHeapFlags\',\'H,CSDVersion\',\'H,DependentLoadFlags\',\'Q,EditList\',\'Q,SecurityCookie\',\'Q,SEHandlerTable\',\'Q,SEHandlerCount\',\'Q,GuardCFCheckFunctionPointer\',\'Q,GuardCFDispatchFunctionPointer\',\'Q,GuardCFFunctionTable\',\'Q,GuardCFFunctionCount\',\'I,GuardFlags\',\'H,CodeIntegrityFlags\',\'H,CodeIntegrityCatalog\',\'I,CodeIntegrityCatalogOffset\',\'I,CodeIntegrityReserved\',\'Q,GuardAddressTakenIatEntryTable\',\'Q,GuardAddressTakenIatEntryCount\',\'Q,GuardLongJumpTargetTable\',\'Q,GuardLongJumpTargetCount\',\'Q,DynamicValueRelocTable\',\'Q,CHPEMetadataPointer\',\'Q,GuardRFFailureRoutine\',\'Q,GuardRFFailureRoutineFunctionPointer\',\'I,DynamicValueRelocTableOffset\',\'H,DynamicValueRelocTableSection\',\'H,Reserved2\',\'Q,GuardRFVerifyStackPointerFunctionPointer\',\'I,HotPatchTableOffset\',\'I,Reserved3\',\'Q,EnclaveConfigurationPointer\',\'Q,VolatileMetadataPointer\',\'Q,GuardEHContinuationTable\',\'Q,GuardEHContinuationCount\',\'Q,GuardXFGCheckFunctionPointer\',\'Q,GuardXFGDispatchFunctionPointer\',\'Q,GuardXFGTableDispatchFunctionPointer\',\'Q,CastGuardOsDeterminedFailureMode\',\'Q,GuardMemcpyFunctionPointer\');__IMAGE_DYNAMIC_RELOCATION_TABLE_format__=\'IMAGE_DYNAMIC_RELOCATION_TABLE\',(\'I,Version\',\'I,Size\');__IMAGE_DYNAMIC_RELOCATION_format__=\'IMAGE_DYNAMIC_RELOCATION\',(\'I,Symbol\',\'I,BaseRelocSize\');__IMAGE_DYNAMIC_RELOCATION64_format__=\'IMAGE_DYNAMIC_RELOCATION64\',(\'Q,Symbol\',\'I,BaseRelocSize\');__IMAGE_DYNAMIC_RELOCATION_V2_format__=\'IMAGE_DYNAMIC_RELOCATION_V2\',(\'I,HeaderSize\',\'I,FixupInfoSize\',\'I,Symbol\',\'I,SymbolGroup\',\'I,Flags\');__IMAGE_DYNAMIC_RELOCATION64_V2_format__=\'IMAGE_DYNAMIC_RELOCATION64_V2\',(\'I,HeaderSize\',\'I,FixupInfoSize\',\'Q,Symbol\',\'I,SymbolGroup\',\'I,Flags\');__IMAGE_BOUND_IMPORT_DESCRIPTOR_format__=\'IMAGE_BOUND_IMPORT_DESCRIPTOR\',(\'I,TimeDateStamp\',\'H,OffsetModuleName\',\'H,NumberOfModuleForwarderRefs\');__IMAGE_BOUND_FORWARDER_REF_format__=\'IMAGE_BOUND_FORWARDER_REF\',(\'I,TimeDateStamp\',\'H,OffsetModuleName\',\'H,Reserved\');__RUNTIME_FUNCTION_format__=\'RUNTIME_FUNCTION\',(\'I,BeginAddress\',\'I,EndAddress\',\'I,UnwindData\')\n    def __init__(self,name=None,data=None,fast_load=None,max_symbol_exports=MAX_SYMBOL_EXPORT_COUNT,max_repeated_symbol=120):\n        self.max_symbol_exports=max_symbol_exports;self.max_repeated_symbol=max_repeated_symbol;self._get_section_by_rva_last_used=None;self.sections=[];self.__warnings=[];self.PE_TYPE=None\n        if name is None and data is None:raise ValueError(\'Must supply either name or data\')\n        self.__structures__=[];self.__from_file=None;self.FileAlignment_Warning=False;self.SectionAlignment_Warning=False;self.__total_resource_entries_count=0;self.__total_resource_bytes=0;self.__total_import_symbols=0;self.dynamic_relocation_format_by_symbol={3:PE.__IMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION_format__,4:PE.__IMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION_format__,5:PE.__IMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION_format__};fast_load=fast_load if fast_load is not None else globals()[\'fast_load\']\n        try:self.__parse__(name,data,fast_load)\n        except:self.close();raise\n    def __enter__(self):return self\n    def __exit__(self,type,value,traceback):self.close()\n    def _close_data(self):\n        if self.__from_file is True and hasattr(self,\'__data__\')and(isinstance(mmap.mmap,type)and isinstance(self.__data__,mmap.mmap)or\'mmap.mmap\'in repr(type(self.__data__))):self.__data__.close();del self.__data__\n    def close(self):self._close_data()\n    def __unpack_data__(self,format,data,file_offset):\n        structure=Structure(format,file_offset=file_offset)\n        try:structure.__unpack__(data)\n        except PEFormatError as err:self.__warnings.append(\'Corrupt header "{0}" at file offset {1}. Exception: {2}\'.format(format[0],file_offset,err));return\n        self.__structures__.append(structure);return structure\n    def __unpack_data_with_bitfields__(self,format,data,file_offset):\n        structure=StructureWithBitfields(format,file_offset=file_offset)\n        try:structure.__unpack__(data)\n        except PEFormatError as err:self.__warnings.append(\'Corrupt header "{0}" at file offset {1}. Exception: {2}\'.format(format[0],file_offset,err));return\n        self.__structures__.append(structure);return structure\n    def __parse__(self,fname,data,fast_load):\n        if fname is not None:\n            stat=os.stat(fname)\n            if stat.st_size==0:raise PEFormatError(\'The file is empty\')\n            fd=None\n            try:\n                fd=open(fname,\'rb\');self.fileno=fd.fileno()\n                if hasattr(mmap,\'MAP_PRIVATE\'):self.__data__=mmap.mmap(self.fileno,0,mmap.MAP_PRIVATE)\n                else:self.__data__=mmap.mmap(self.fileno,0,access=mmap.ACCESS_READ)\n                self.__from_file=True\n            except IOError as excp:exception_msg=\'{0}\'.format(excp);exception_msg=exception_msg and\': %s\'%exception_msg;raise Exception("Unable to access file \'{0}\'{1}".format(fname,exception_msg))\n            finally:\n                if fd is not None:fd.close()\n        elif data is not None:self.__data__=data;self.__from_file=False\n        self.__resource_size_limit_upperbounds=len(self.__data__);self.__resource_size_limit_reached=False\n        if not fast_load:\n            for(byte,byte_count)in Counter(bytearray(self.__data__)).items():\n                if byte==0 and byte_count/len(self.__data__)>.5 or byte!=0 and byte_count/len(self.__data__)>.15:self.__warnings.append("Byte 0x{0:02x} makes up {1:.4f}% of the file\'s contents. This may indicate truncation / malformation.".format(byte,1e2*byte_count/len(self.__data__)))\n        dos_header_data=self.__data__[:64]\n        if len(dos_header_data)!=64:raise PEFormatError(\'Unable to read the DOS Header, possibly a truncated file.\')\n        self.DOS_HEADER=self.__unpack_data__(self.__IMAGE_DOS_HEADER_format__,dos_header_data,file_offset=0)\n        if self.DOS_HEADER.e_magic==IMAGE_DOSZM_SIGNATURE:raise PEFormatError(\'Probably a ZM Executable (not a PE file).\')\n        if not self.DOS_HEADER or self.DOS_HEADER.e_magic!=IMAGE_DOS_SIGNATURE:raise PEFormatError(\'DOS Header magic not found.\')\n        if self.DOS_HEADER.e_lfanew>len(self.__data__):raise PEFormatError(\'Invalid e_lfanew value, probably not a PE file\')\n        nt_headers_offset=self.DOS_HEADER.e_lfanew;self.NT_HEADERS=self.__unpack_data__(self.__IMAGE_NT_HEADERS_format__,self.__data__[nt_headers_offset:nt_headers_offset+8],file_offset=nt_headers_offset)\n        if not self.NT_HEADERS or not self.NT_HEADERS.Signature:raise PEFormatError(\'NT Headers not found.\')\n        if 65535&self.NT_HEADERS.Signature==IMAGE_NE_SIGNATURE:raise PEFormatError(\'Invalid NT Headers signature. Probably a NE file\')\n        if 65535&self.NT_HEADERS.Signature==IMAGE_LE_SIGNATURE:raise PEFormatError(\'Invalid NT Headers signature. Probably a LE file\')\n        if 65535&self.NT_HEADERS.Signature==IMAGE_LX_SIGNATURE:raise PEFormatError(\'Invalid NT Headers signature. Probably a LX file\')\n        if 65535&self.NT_HEADERS.Signature==IMAGE_TE_SIGNATURE:raise PEFormatError(\'Invalid NT Headers signature. Probably a TE file\')\n        if self.NT_HEADERS.Signature!=IMAGE_NT_SIGNATURE:raise PEFormatError(\'Invalid NT Headers signature.\')\n        self.FILE_HEADER=self.__unpack_data__(self.__IMAGE_FILE_HEADER_format__,self.__data__[nt_headers_offset+4:nt_headers_offset+4+32],file_offset=nt_headers_offset+4);image_flags=retrieve_flags(IMAGE_CHARACTERISTICS,\'IMAGE_FILE_\')\n        if not self.FILE_HEADER:raise PEFormatError(\'File Header missing\')\n        set_flags(self.FILE_HEADER,self.FILE_HEADER.Characteristics,image_flags);optional_header_offset=nt_headers_offset+4+self.FILE_HEADER.sizeof();sections_offset=optional_header_offset+self.FILE_HEADER.SizeOfOptionalHeader;self.OPTIONAL_HEADER=self.__unpack_data__(self.__IMAGE_OPTIONAL_HEADER_format__,self.__data__[optional_header_offset:optional_header_offset+256],file_offset=optional_header_offset);MINIMUM_VALID_OPTIONAL_HEADER_RAW_SIZE=69\n        if self.OPTIONAL_HEADER is None and len(self.__data__[optional_header_offset:optional_header_offset+512])>=MINIMUM_VALID_OPTIONAL_HEADER_RAW_SIZE:padding_length=128;padded_data=self.__data__[optional_header_offset:optional_header_offset+512]+b\'\\x00\'*padding_length;self.OPTIONAL_HEADER=self.__unpack_data__(self.__IMAGE_OPTIONAL_HEADER_format__,padded_data,file_offset=optional_header_offset)\n        if self.OPTIONAL_HEADER is not None:\n            if self.OPTIONAL_HEADER.Magic==OPTIONAL_HEADER_MAGIC_PE:self.PE_TYPE=OPTIONAL_HEADER_MAGIC_PE\n            elif self.OPTIONAL_HEADER.Magic==OPTIONAL_HEADER_MAGIC_PE_PLUS:\n                self.PE_TYPE=OPTIONAL_HEADER_MAGIC_PE_PLUS;self.OPTIONAL_HEADER=self.__unpack_data__(self.__IMAGE_OPTIONAL_HEADER64_format__,self.__data__[optional_header_offset:optional_header_offset+512],file_offset=optional_header_offset);MINIMUM_VALID_OPTIONAL_HEADER_RAW_SIZE=73\n                if self.OPTIONAL_HEADER is None and len(self.__data__[optional_header_offset:optional_header_offset+512])>=MINIMUM_VALID_OPTIONAL_HEADER_RAW_SIZE:padding_length=128;padded_data=self.__data__[optional_header_offset:optional_header_offset+512]+b\'\\x00\'*padding_length;self.OPTIONAL_HEADER=self.__unpack_data__(self.__IMAGE_OPTIONAL_HEADER64_format__,padded_data,file_offset=optional_header_offset)\n        if not self.FILE_HEADER:raise PEFormatError(\'File Header missing\')\n        if self.OPTIONAL_HEADER is None:raise PEFormatError(\'No Optional Header found, invalid PE32 or PE32+ file.\')\n        if self.PE_TYPE is None:self.__warnings.append(\'Invalid type 0x{0:04x} in Optional Header.\'.format(self.OPTIONAL_HEADER.Magic))\n        dll_characteristics_flags=retrieve_flags(DLL_CHARACTERISTICS,\'IMAGE_DLLCHARACTERISTICS_\');set_flags(self.OPTIONAL_HEADER,self.OPTIONAL_HEADER.DllCharacteristics,dll_characteristics_flags);self.OPTIONAL_HEADER.DATA_DIRECTORY=[];offset=optional_header_offset+self.OPTIONAL_HEADER.sizeof();self.NT_HEADERS.FILE_HEADER=self.FILE_HEADER;self.NT_HEADERS.OPTIONAL_HEADER=self.OPTIONAL_HEADER\n        if self.OPTIONAL_HEADER.AddressOfEntryPoint<self.OPTIONAL_HEADER.SizeOfHeaders:self.__warnings.append(\'SizeOfHeaders is smaller than AddressOfEntryPoint: this file cannot run under Windows 8.\')\n        if self.OPTIONAL_HEADER.NumberOfRvaAndSizes>16:self.__warnings.append(\'Suspicious NumberOfRvaAndSizes in the Optional Header. Normal values are never larger than 0x10, the value is: 0x%x\'%self.OPTIONAL_HEADER.NumberOfRvaAndSizes)\n        MAX_ASSUMED_VALID_NUMBER_OF_RVA_AND_SIZES=256\n        for i in range(int(2147483647&self.OPTIONAL_HEADER.NumberOfRvaAndSizes)):\n            if len(self.__data__)-offset==0:break\n            if len(self.__data__)-offset<8:data=self.__data__[offset:]+b\'\\x00\'*8\n            else:data=self.__data__[offset:offset+MAX_ASSUMED_VALID_NUMBER_OF_RVA_AND_SIZES]\n            dir_entry=self.__unpack_data__(self.__IMAGE_DATA_DIRECTORY_format__,data,file_offset=offset)\n            if dir_entry is None:break\n            try:dir_entry.name=DIRECTORY_ENTRY[i]\n            except(KeyError,AttributeError):break\n            offset+=dir_entry.sizeof();self.OPTIONAL_HEADER.DATA_DIRECTORY.append(dir_entry)\n            if offset>=optional_header_offset+self.OPTIONAL_HEADER.sizeof()+128:break\n        offset=self.parse_sections(sections_offset);rawDataPointers=[self.adjust_PointerToRawData(s.PointerToRawData)for s in self.sections if s.PointerToRawData>0]\n        if len(rawDataPointers)>0:lowest_section_offset=min(rawDataPointers)\n        else:lowest_section_offset=None\n        if not lowest_section_offset or lowest_section_offset<offset:self.header=self.__data__[:offset]\n        else:self.header=self.__data__[:lowest_section_offset]\n        if self.get_section_by_rva(self.OPTIONAL_HEADER.AddressOfEntryPoint)is not None:\n            ep_offset=self.get_offset_from_rva(self.OPTIONAL_HEADER.AddressOfEntryPoint)\n            if ep_offset>len(self.__data__):self.__warnings.append(\'Possibly corrupt file. AddressOfEntryPoint lies outside the file. AddressOfEntryPoint: 0x%x\'%self.OPTIONAL_HEADER.AddressOfEntryPoint)\n        else:self.__warnings.append("AddressOfEntryPoint lies outside the sections\' boundaries. AddressOfEntryPoint: 0x%x"%self.OPTIONAL_HEADER.AddressOfEntryPoint)\n        if not fast_load:self.full_load()\n    def parse_rich_header(self):\n        DANS=1399742788;RICH=1751345490;rich_index=self.__data__.find(b\'Rich\',128,self.OPTIONAL_HEADER.get_file_offset())\n        if rich_index==-1:return\n        try:\n            rich_data=self.__data__[128:rich_index+8];rich_data=rich_data[:4*(len(rich_data)//4)];data=list(struct.unpack(\'<{0}I\'.format(len(rich_data)//4),rich_data))\n            if RICH not in data:return\n        except PEFormatError:return\n        key=struct.pack(\'<L\',data[data.index(RICH)+1]);result={\'key\':key};raw_data=rich_data[:rich_data.find(b\'Rich\')];result[\'raw_data\']=raw_data;ord_=lambda c:ord(c)if not isinstance(c,int)else c;clear_data=bytearray()\n        for(idx,val)in enumerate(raw_data):clear_data.append(ord_(val)^ord_(key[idx%len(key)]))\n        result[\'clear_data\']=bytes(clear_data);checksum=int.from_bytes(key,\'little\')\n        if data[0]^checksum!=DANS or data[1]!=checksum or data[2]!=checksum or data[3]!=checksum:self.__warnings.append(\'Rich Header is not in Microsoft format, possibly malformed\')\n        result[\'checksum\']=checksum;headervalues=[];result[\'values\']=headervalues;data=data[4:]\n        for i in range(len(data)//2):\n            if data[2*i]==RICH:\n                if data[2*i+1]!=checksum:self.__warnings.append(\'Rich Header is malformed\')\n                break\n            headervalues+=[data[2*i]^checksum,data[2*i+1]^checksum]\n        return result\n    def get_warnings(self):return self.__warnings\n    def show_warnings(self):\n        for warning in self.__warnings:print(\'>\',warning)\n    def full_load(self):\n        self.parse_data_directories()\n        class RichHeader:0\n        rich_header=self.parse_rich_header()\n        if rich_header:self.RICH_HEADER=RichHeader();self.RICH_HEADER.checksum=rich_header.get(\'checksum\',None);self.RICH_HEADER.values=rich_header.get(\'values\',None);self.RICH_HEADER.key=rich_header.get(\'key\',None);self.RICH_HEADER.raw_data=rich_header.get(\'raw_data\',None);self.RICH_HEADER.clear_data=rich_header.get(\'clear_data\',None)\n        else:self.RICH_HEADER=None\n    def write(self,filename=None):\n        file_data=bytearray(self.__data__)\n        for structure in self.__structures__:struct_data=bytearray(structure.__pack__());offset=structure.get_file_offset();file_data[offset:offset+len(struct_data)]=struct_data\n        if hasattr(self,\'VS_VERSIONINFO\'):\n            if hasattr(self,\'FileInfo\'):\n                for finfo in self.FileInfo:\n                    for entry in finfo:\n                        if hasattr(entry,\'StringTable\'):\n                            for st_entry in entry.StringTable:\n                                for(key,entry)in list(st_entry.entries.items()):\n                                    offsets=st_entry.entries_offsets[key];lengths=st_entry.entries_lengths[key]\n                                    if len(entry)>lengths[1]:l=entry.decode(\'utf-8\').encode(\'utf-16le\');file_data[offsets[1]:offsets[1]+lengths[1]*2]=l[:lengths[1]*2]\n                                    else:encoded_data=entry.decode(\'utf-8\').encode(\'utf-16le\');file_data[offsets[1]:offsets[1]+len(encoded_data)]=encoded_data\n        new_file_data=file_data\n        if not filename:return new_file_data\n        with open(filename,\'wb+\')as f:f.write(new_file_data)\n    def parse_sections(self,offset):\n        self.sections=[];MAX_SIMULTANEOUS_ERRORS=3\n        for i in range(self.FILE_HEADER.NumberOfSections):\n            if i>=MAX_SECTIONS:self.__warnings.append(\'Too many sections {0} (>={1})\'.format(self.FILE_HEADER.NumberOfSections,MAX_SECTIONS));break\n            simultaneous_errors=0;section=SectionStructure(self.__IMAGE_SECTION_HEADER_format__,pe=self)\n            if not section:break\n            section_offset=offset+section.sizeof()*i;section.set_file_offset(section_offset);section_data=self.__data__[section_offset:section_offset+section.sizeof()]\n            if count_zeroes(section_data)==section.sizeof():self.__warnings.append(f"Invalid section {i}. Contents are null-bytes.");break\n            if not section_data:self.__warnings.append(f"Invalid section {i}. No data in the file (is this corkami\'s virtsectblXP?).");break\n            section.__unpack__(section_data);self.__structures__.append(section)\n            if section.SizeOfRawData+section.PointerToRawData>len(self.__data__):simultaneous_errors+=1;self.__warnings.append(f"Error parsing section {i}. SizeOfRawData is larger than file.")\n            if self.adjust_PointerToRawData(section.PointerToRawData)>len(self.__data__):simultaneous_errors+=1;self.__warnings.append(f"Error parsing section {i}. PointerToRawData points beyond the end of the file.")\n            if section.Misc_VirtualSize>268435456:simultaneous_errors+=1;self.__warnings.append(f"Suspicious value found parsing section {i}. VirtualSize is extremely large > 256MiB.")\n            if self.adjust_SectionAlignment(section.VirtualAddress,self.OPTIONAL_HEADER.SectionAlignment,self.OPTIONAL_HEADER.FileAlignment)>268435456:simultaneous_errors+=1;self.__warnings.append(f"Suspicious value found parsing section {i}. VirtualAddress is beyond 0x10000000.")\n            if self.OPTIONAL_HEADER.FileAlignment!=0 and section.PointerToRawData%self.OPTIONAL_HEADER.FileAlignment!=0:simultaneous_errors+=1;self.__warnings.append(f"Error parsing section {i}. PointerToRawData should normally be a multiple of FileAlignment, this might imply the file is trying to confuse tools which parse this incorrectly.")\n            if simultaneous_errors>=MAX_SIMULTANEOUS_ERRORS:self.__warnings.append(\'Too many warnings parsing section. Aborting.\');break\n            section_flags=retrieve_flags(SECTION_CHARACTERISTICS,\'IMAGE_SCN_\');set_flags(section,section.Characteristics,section_flags)\n            if section.__dict__.get(\'IMAGE_SCN_MEM_WRITE\',False)and section.__dict__.get(\'IMAGE_SCN_MEM_EXECUTE\',False):\n                if section.Name.rstrip(b\'\\x00\')==b\'PAGE\'and self.is_driver():0\n                else:self.__warnings.append(f"Suspicious flags set for section {i}. Both IMAGE_SCN_MEM_WRITE and IMAGE_SCN_MEM_EXECUTE are set. This might indicate a packed executable.")\n            self.sections.append(section)\n        self.sections.sort(key=lambda a:a.VirtualAddress)\n        for(idx,section)in enumerate(self.sections):\n            if idx==len(self.sections)-1:section.next_section_virtual_address=None\n            else:section.next_section_virtual_address=self.sections[idx+1].VirtualAddress\n        if self.FILE_HEADER.NumberOfSections>0 and self.sections:return offset+self.sections[0].sizeof()*self.FILE_HEADER.NumberOfSections\n        else:return offset\n    def parse_data_directories(self,directories=None,forwarded_exports_only=False,import_dllnames_only=False):\n        directory_parsing=(\'IMAGE_DIRECTORY_ENTRY_IMPORT\',self.parse_import_directory),(\'IMAGE_DIRECTORY_ENTRY_EXPORT\',self.parse_export_directory),(\'IMAGE_DIRECTORY_ENTRY_RESOURCE\',self.parse_resources_directory),(\'IMAGE_DIRECTORY_ENTRY_DEBUG\',self.parse_debug_directory),(\'IMAGE_DIRECTORY_ENTRY_BASERELOC\',self.parse_relocations_directory),(\'IMAGE_DIRECTORY_ENTRY_TLS\',self.parse_directory_tls),(\'IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG\',self.parse_directory_load_config),(\'IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT\',self.parse_delay_import_directory),(\'IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT\',self.parse_directory_bound_imports),(\'IMAGE_DIRECTORY_ENTRY_EXCEPTION\',self.parse_exceptions_directory)\n        if directories is not None:\n            if not isinstance(directories,(tuple,list)):directories=[directories]\n        for entry in directory_parsing:\n            try:directory_index=DIRECTORY_ENTRY[entry[0]];dir_entry=self.OPTIONAL_HEADER.DATA_DIRECTORY[directory_index]\n            except IndexError:break\n            if directories is None or directory_index in directories:\n                value=None\n                if dir_entry.VirtualAddress:\n                    if forwarded_exports_only and entry[0]==\'IMAGE_DIRECTORY_ENTRY_EXPORT\':value=entry[1](dir_entry.VirtualAddress,dir_entry.Size,forwarded_only=True)\n                    elif import_dllnames_only and entry[0]==\'IMAGE_DIRECTORY_ENTRY_IMPORT\':value=entry[1](dir_entry.VirtualAddress,dir_entry.Size,dllnames_only=True)\n                    else:\n                        try:value=entry[1](dir_entry.VirtualAddress,dir_entry.Size)\n                        except PEFormatError as excp:self.__warnings.append(f\'Failed to process directory "{entry[0]}": {excp}\')\n                    if value:setattr(self,entry[0][6:],value)\n            if directories is not None and isinstance(directories,list)and entry[0]in directories:directories.remove(directory_index)\n    def parse_exceptions_directory(self,rva,size):\n        if self.FILE_HEADER.Machine!=MACHINE_TYPE[\'IMAGE_FILE_MACHINE_AMD64\']and self.FILE_HEADER.Machine!=MACHINE_TYPE[\'IMAGE_FILE_MACHINE_IA64\']:return\n        rf=Structure(self.__RUNTIME_FUNCTION_format__);rf_size=rf.sizeof();rva2rt={};rt_funcs=[];rva2infos={}\n        for _ in range(size//rf_size):\n            rf=self.__unpack_data__(self.__RUNTIME_FUNCTION_format__,self.get_data(rva,rf_size),file_offset=self.get_offset_from_rva(rva))\n            if rf is None:break\n            ui=None\n            if rf.UnwindData&1==0:\n                if rf.UnwindData in rva2infos:ui=rva2infos[rf.UnwindData]\n                else:ui=UnwindInfo(file_offset=self.get_offset_from_rva(rf.UnwindData));rva2infos[rf.UnwindData]=ui\n                ws=ui.unpack_in_stages(self.get_data(rf.UnwindData,ui.sizeof()))\n                if ws!=None:self.__warnings.append(ws);break\n                ws=ui.unpack_in_stages(self.get_data(rf.UnwindData,ui.sizeof()))\n                if ws!=None:self.__warnings.append(ws);break\n                self.__structures__.append(ui)\n            entry=ExceptionsDirEntryData(struct=rf,unwindinfo=ui);rt_funcs.append(entry);rva2rt[rf.BeginAddress]=entry;rva+=rf_size\n        for rf in rt_funcs:\n            if rf.unwindinfo is None:continue\n            if not hasattr(rf.unwindinfo,\'FunctionEntry\'):continue\n            if rf.unwindinfo.FunctionEntry not in rva2rt:self.__warnings.append(f"FunctionEntry of UNWIND_INFO at {rf.struct.get_file_offset():x} points to an entry that does not exist");continue\n            try:rf.unwindinfo.set_chained_function_entry(rva2rt[rf.unwindinfo.FunctionEntry])\n            except PEFormatError as excp:self.__warnings.append(f"Failed parsing FunctionEntry of UNWIND_INFO at {rf.struct.get_file_offset():x}: {excp}");continue\n        return rt_funcs\n    def parse_directory_bound_imports(self,rva,size):\n        bnd_descr=Structure(self.__IMAGE_BOUND_IMPORT_DESCRIPTOR_format__);bnd_descr_size=bnd_descr.sizeof();start=rva;bound_imports=[]\n        while True:\n            bnd_descr=self.__unpack_data__(self.__IMAGE_BOUND_IMPORT_DESCRIPTOR_format__,self.__data__[rva:rva+bnd_descr_size],file_offset=rva)\n            if bnd_descr is None:self.__warnings.append("The Bound Imports directory exists but can\'t be parsed.");return\n            if bnd_descr.all_zeroes():break\n            rva+=bnd_descr.sizeof();section=self.get_section_by_offset(rva);file_offset=self.get_offset_from_rva(rva)\n            if section is None:\n                safety_boundary=len(self.__data__)-file_offset;sections_after_offset=[s.PointerToRawData for s in self.sections if s.PointerToRawData>file_offset]\n                if sections_after_offset:\n                    first_section_after_offset=min(sections_after_offset);section=self.get_section_by_offset(first_section_after_offset)\n                    if section is not None:safety_boundary=section.PointerToRawData-file_offset\n            else:safety_boundary=section.PointerToRawData+len(section.get_data())-file_offset\n            if not section:self.__warnings.append(\'RVA of IMAGE_BOUND_IMPORT_DESCRIPTOR points to an invalid address: {0:x}\'.format(rva));return\n            forwarder_refs=[]\n            for _ in range(min(bnd_descr.NumberOfModuleForwarderRefs,int(safety_boundary/8))):\n                bnd_frwd_ref=self.__unpack_data__(self.__IMAGE_BOUND_FORWARDER_REF_format__,self.__data__[rva:rva+bnd_descr_size],file_offset=rva)\n                if not bnd_frwd_ref:raise PEFormatError(\'IMAGE_BOUND_FORWARDER_REF cannot be read\')\n                rva+=bnd_frwd_ref.sizeof();offset=start+bnd_frwd_ref.OffsetModuleName;name_str=self.get_string_from_data(0,self.__data__[offset:offset+MAX_STRING_LENGTH])\n                if name_str:\n                    invalid_chars=[c for c in bytearray(name_str)if chr(c)not in string.printable]\n                    if len(name_str)>256 or invalid_chars:break\n                forwarder_refs.append(BoundImportRefData(struct=bnd_frwd_ref,name=name_str))\n            offset=start+bnd_descr.OffsetModuleName;name_str=self.get_string_from_data(0,self.__data__[offset:offset+MAX_STRING_LENGTH])\n            if name_str:\n                invalid_chars=[c for c in bytearray(name_str)if chr(c)not in string.printable]\n                if len(name_str)>256 or invalid_chars:break\n            if not name_str:break\n            bound_imports.append(BoundImportDescData(struct=bnd_descr,name=name_str,entries=forwarder_refs))\n        return bound_imports\n    def parse_directory_tls(self,rva,size):\n        format=self.__IMAGE_TLS_DIRECTORY_format__\n        if self.PE_TYPE==OPTIONAL_HEADER_MAGIC_PE_PLUS:format=self.__IMAGE_TLS_DIRECTORY64_format__\n        try:tls_struct=self.__unpack_data__(format,self.get_data(rva,Structure(format).sizeof()),file_offset=self.get_offset_from_rva(rva))\n        except PEFormatError:self.__warnings.append("Invalid TLS information. Can\'t read data at RVA: 0x%x"%rva);tls_struct=None\n        if not tls_struct:return\n        return TlsData(struct=tls_struct)\n    def parse_directory_load_config(self,rva,size):\n        if self.PE_TYPE==OPTIONAL_HEADER_MAGIC_PE:load_config_dir_sz=self.get_dword_at_rva(rva);format=self.__IMAGE_LOAD_CONFIG_DIRECTORY_format__\n        elif self.PE_TYPE==OPTIONAL_HEADER_MAGIC_PE_PLUS:load_config_dir_sz=self.get_dword_at_rva(rva);format=self.__IMAGE_LOAD_CONFIG_DIRECTORY64_format__\n        else:self.__warnings.append("Don\'t know how to parse LOAD_CONFIG information for non-PE32/PE32+ file");return\n        fields_counter=0;cumulative_sz=0\n        for field in format[1]:\n            fields_counter+=1;cumulative_sz+=STRUCT_SIZEOF_TYPES[field.split(\',\')[0]]\n            if cumulative_sz==load_config_dir_sz:break\n        format=format[0],format[1][:fields_counter];load_config_struct=None\n        try:load_config_struct=self.__unpack_data__(format,self.get_data(rva,Structure(format).sizeof()),file_offset=self.get_offset_from_rva(rva))\n        except PEFormatError:self.__warnings.append("Invalid LOAD_CONFIG information. Can\'t read data at RVA: 0x%x"%rva)\n        if not load_config_struct:return\n        dynamic_relocations=None\n        if fields_counter>35:dynamic_relocations=self.parse_dynamic_relocations(load_config_struct.DynamicValueRelocTableOffset,load_config_struct.DynamicValueRelocTableSection)\n        return LoadConfigData(struct=load_config_struct,dynamic_relocations=dynamic_relocations)\n    def parse_dynamic_relocations(self,dynamic_value_reloc_table_offset,dynamic_value_reloc_table_section):\n        if not dynamic_value_reloc_table_offset:return\n        if not dynamic_value_reloc_table_section:return\n        if dynamic_value_reloc_table_section>len(self.sections):return\n        section=self.sections[dynamic_value_reloc_table_section-1];rva=section.VirtualAddress+dynamic_value_reloc_table_offset;image_dynamic_reloc_table_struct=None;reloc_table_size=Structure(self.__IMAGE_DYNAMIC_RELOCATION_TABLE_format__).sizeof()\n        try:image_dynamic_reloc_table_struct=self.__unpack_data__(self.__IMAGE_DYNAMIC_RELOCATION_TABLE_format__,self.get_data(rva,reloc_table_size),file_offset=self.get_offset_from_rva(rva))\n        except PEFormatError:self.__warnings.append("Invalid IMAGE_DYNAMIC_RELOCATION_TABLE information. Can\'t read data at RVA: 0x%x"%rva);return\n        if image_dynamic_reloc_table_struct.Version!=1:self.__warnings.append(\'No parsing available for IMAGE_DYNAMIC_RELOCATION_TABLE.Version = %d\'%image_dynamic_reloc_table_struct.Version);return\n        rva+=reloc_table_size;end=rva+image_dynamic_reloc_table_struct.Size;dynamic_relocations=[]\n        while rva<end:\n            format=self.__IMAGE_DYNAMIC_RELOCATION_format__\n            if self.PE_TYPE==OPTIONAL_HEADER_MAGIC_PE_PLUS:format=self.__IMAGE_DYNAMIC_RELOCATION64_format__\n            rlc_size=Structure(format).sizeof()\n            try:dynamic_rlc=self.__unpack_data__(format,self.get_data(rva,rlc_size),file_offset=self.get_offset_from_rva(rva))\n            except PEFormatError:self.__warnings.append("Invalid relocation information. Can\'t read data at RVA: 0x%x"%rva);dynamic_rlc=None\n            if not dynamic_rlc:break\n            rva+=rlc_size;symbol=dynamic_rlc.Symbol;size=dynamic_rlc.BaseRelocSize\n            if 3<=symbol<=5:relocations=self.parse_image_base_relocation_list(rva,size,self.dynamic_relocation_format_by_symbol[symbol]);dynamic_relocations.append(DynamicRelocationData(struct=dynamic_rlc,symbol=symbol,relocations=relocations))\n            elif symbol==7:func_relocs,bdd_relocs=self.parse_function_override_data(rva);dynamic_relocations.append(FunctionOverrideData(struct=dynamic_rlc,symbol=symbol,bdd_relocs=bdd_relocs,func_relocs=func_relocs))\n            elif symbol>5:relocations=self.parse_image_base_relocation_list(rva,size);dynamic_relocations.append(DynamicRelocationData(struct=dynamic_rlc,symbol=symbol,relocations=relocations))\n            rva+=size\n        return dynamic_relocations\n    def parse_function_override_data(self,rva):\n        func_relocs=[];bdd_relocs=[];format=self.__IMAGE_FUNCTION_OVERRIDE_HEADER_format__;func_header=self.__unpack_data__(format,self.get_data(rva,Structure(format).sizeof()),self.get_offset_from_rva(rva))\n        if not func_header:self.__warnings.append("Invalid function override header. Can\'t read data at RVA: 0x%x"%rva);return func_relocs,bdd_relocs\n        rva+=Structure(format).sizeof();func_end=rva+func_header.FuncOverrideSize\n        while rva<func_end:\n            format=self.__IMAGE_FUNCTION_OVERRIDE_DYNAMIC_RELOCATION_format__;func_info=self.__unpack_data__(format,self.get_data(rva,Structure(format).sizeof()),self.get_offset_from_rva(rva))\n            if not func_info:self.__warnings.append("Invalid function override info. Can\'t read data at RVA: 0x%x"%rva);return func_relocs,bdd_relocs\n            rva+=Structure(format).sizeof();override_rvas=[]\n            for i in range(func_info.RvaSize//4):override_rvas.append(struct.unpack(\'<I\',self.get_data(rva,4))[0]);rva+=4\n            relocations=self.parse_image_base_relocation_list(rva,func_info.BaseRelocSize);rva+=func_info.BaseRelocSize;func_relocs.append(FunctionOverrideDynamicRelocationData(struct=func_info,func_rva=func_info.OriginalRva,override_rvas=override_rvas,relocations=relocations))\n        format=self.__IMAGE_BDD_INFO_format__;bdd_info=self.__unpack_data__(format,self.get_data(rva,Structure(format).sizeof()),self.get_offset_from_rva(rva))\n        if not bdd_info:self.__warnings.append("Invalid bdd info. Can\'t read data at RVA: 0x%x"%rva);return func_relocs,bdd_relocs\n        rva+=Structure(format).sizeof()\n        for i in range(bdd_info.BDDSize//8):\n            format=self.__IMAGE_BDD_DYNAMIC_RELOCATION_format__;bdd_reloc=self.__unpack_data__(format,self.get_data(rva,Structure(format).sizeof()),self.get_offset_from_rva(rva))\n            if not bdd_reloc:self.__warnings.append("Invalid bdd dynamic relocation. Can\'t read data at RVA: 0x%x"%rva);return func_relocs,bdd_relocs\n            rva+=Structure(format).sizeof();bdd_relocs.append(BddDynamicRelocationData(struct=bdd_reloc))\n        return func_relocs,bdd_relocs\n    def parse_relocations_directory(self,rva,size):return self.parse_image_base_relocation_list(rva,size)\n    def parse_image_base_relocation_list(self,rva,size,fmt=None):\n        rlc_size=Structure(self.__IMAGE_BASE_RELOCATION_format__).sizeof();end=rva+size;relocations=[]\n        while rva<end:\n            try:rlc=self.__unpack_data__(self.__IMAGE_BASE_RELOCATION_format__,self.get_data(rva,rlc_size),file_offset=self.get_offset_from_rva(rva))\n            except PEFormatError:self.__warnings.append("Invalid relocation information. Can\'t read data at RVA: 0x%x"%rva);rlc=None\n            if not rlc:break\n            if rlc.VirtualAddress>self.OPTIONAL_HEADER.SizeOfImage:self.__warnings.append(\'Invalid relocation information. VirtualAddress outside of Image: 0x%x\'%rlc.VirtualAddress);break\n            if rlc.SizeOfBlock>self.OPTIONAL_HEADER.SizeOfImage:self.__warnings.append(\'Invalid relocation information. SizeOfBlock too large: %d\'%rlc.SizeOfBlock);break\n            if fmt is None:reloc_entries=self.parse_relocations(rva+rlc_size,rlc.VirtualAddress,rlc.SizeOfBlock-rlc_size)\n            else:reloc_entries=self.parse_relocations_with_format(rva+rlc_size,rlc.VirtualAddress,rlc.SizeOfBlock-rlc_size,fmt)\n            relocations.append(BaseRelocationData(struct=rlc,entries=reloc_entries))\n            if not rlc.SizeOfBlock:break\n            rva+=rlc.SizeOfBlock\n        return relocations\n    def parse_relocations(self,data_rva,rva,size):\n        try:data=self.get_data(data_rva,size);file_offset=self.get_offset_from_rva(data_rva)\n        except PEFormatError:self.__warnings.append(f"Bad RVA in relocation data: 0x{data_rva:x}");return[]\n        entries=[];offsets_and_type=set()\n        for idx in range(len(data)//2):\n            entry=self.__unpack_data__(self.__IMAGE_BASE_RELOCATION_ENTRY_format__,data[idx*2:(idx+1)*2],file_offset=file_offset)\n            if not entry:break\n            word=entry.Data;reloc_type=word>>12;reloc_offset=word&4095\n            if(reloc_offset,reloc_type)in offsets_and_type:self.__warnings.append(\'Overlapping offsets in relocation data at RVA: 0x%x\'%(reloc_offset+rva));break\n            offsets_and_type.add((reloc_offset,reloc_type));entries.append(RelocationData(struct=entry,type=reloc_type,base_rva=rva,rva=reloc_offset+rva));file_offset+=entry.sizeof()\n        return entries\n    def parse_relocations_with_format(self,data_rva,rva,size,format):\n        try:data=self.get_data(data_rva,size);file_offset=self.get_offset_from_rva(data_rva)\n        except PEFormatError:self.__warnings.append(f"Bad RVA in relocation data: 0x{data_rva:x}");return[]\n        entry_size=StructureWithBitfields(format).sizeof();entries=[];offsets=set()\n        for idx in range(len(data)//entry_size):\n            entry=self.__unpack_data_with_bitfields__(format,data[idx*entry_size:(idx+1)*entry_size],file_offset=file_offset)\n            if not entry:break\n            reloc_offset=entry.PageRelativeOffset\n            if reloc_offset in offsets:self.__warnings.append(\'Overlapping offsets in relocation data at RVA: 0x%x\'%(reloc_offset+rva));break\n            offsets.add(reloc_offset);entries.append(RelocationData(struct=entry,base_rva=rva,rva=reloc_offset+rva));file_offset+=entry_size\n        return entries\n    def parse_debug_directory(self,rva,size):\n        dbg_size=Structure(self.__IMAGE_DEBUG_DIRECTORY_format__).sizeof();debug=[]\n        for idx in range(int(size/dbg_size)):\n            try:data=self.get_data(rva+dbg_size*idx,dbg_size)\n            except PEFormatError:self.__warnings.append("Invalid debug information. Can\'t read data at RVA: 0x%x"%rva);return\n            dbg=self.__unpack_data__(self.__IMAGE_DEBUG_DIRECTORY_format__,data,file_offset=self.get_offset_from_rva(rva+dbg_size*idx))\n            if not dbg:return\n            dbg_type=None\n            if dbg.Type==1:0\n            elif dbg.Type==2:\n                dbg_type_offset=dbg.PointerToRawData;dbg_type_size=dbg.SizeOfData;dbg_type_data=self.__data__[dbg_type_offset:dbg_type_offset+dbg_type_size]\n                if dbg_type_data[:4]==b\'RSDS\':\n                    __CV_INFO_PDB70_format__=[\'CV_INFO_PDB70\',[\'4s,CvSignature\',\'I,Signature_Data1\',\'H,Signature_Data2\',\'H,Signature_Data3\',\'B,Signature_Data4\',\'B,Signature_Data5\',\'6s,Signature_Data6\',\'I,Age\']];pdbFileName_size=dbg_type_size-Structure(__CV_INFO_PDB70_format__).sizeof()\n                    if pdbFileName_size>0:__CV_INFO_PDB70_format__[1].append(\'{0}s,PdbFileName\'.format(pdbFileName_size))\n                    dbg_type=self.__unpack_data__(__CV_INFO_PDB70_format__,dbg_type_data,dbg_type_offset)\n                    if dbg_type is not None:dbg_type.Signature_Data6_value=struct.unpack(\'>Q\',b\'\\x00\\x00\'+dbg_type.Signature_Data6)[0];dbg_type.Signature_String=str(uuid.UUID(fields=(dbg_type.Signature_Data1,dbg_type.Signature_Data2,dbg_type.Signature_Data3,dbg_type.Signature_Data4,dbg_type.Signature_Data5,dbg_type.Signature_Data6_value))).replace(\'-\',\'\').upper()+f"{dbg_type.Age:X}"\n                elif dbg_type_data[:4]==b\'NB10\':\n                    __CV_INFO_PDB20_format__=[\'CV_INFO_PDB20\',[\'I,CvHeaderSignature\',\'I,CvHeaderOffset\',\'I,Signature\',\'I,Age\']];pdbFileName_size=dbg_type_size-Structure(__CV_INFO_PDB20_format__).sizeof()\n                    if pdbFileName_size>0:__CV_INFO_PDB20_format__[1].append(\'{0}s,PdbFileName\'.format(pdbFileName_size))\n                    dbg_type=self.__unpack_data__(__CV_INFO_PDB20_format__,dbg_type_data,dbg_type_offset)\n            elif dbg.Type==4:\n                dbg_type_offset=dbg.PointerToRawData;dbg_type_size=dbg.SizeOfData;dbg_type_data=self.__data__[dbg_type_offset:dbg_type_offset+dbg_type_size];___IMAGE_DEBUG_MISC_format__=[\'IMAGE_DEBUG_MISC\',[\'I,DataType\',\'I,Length\',\'B,Unicode\',\'B,Reserved1\',\'H,Reserved2\']];dbg_type_partial=self.__unpack_data__(___IMAGE_DEBUG_MISC_format__,dbg_type_data,dbg_type_offset)\n                if dbg_type_partial:\n                    if dbg_type_partial.Unicode in(0,1):\n                        data_size=dbg_type_size-Structure(___IMAGE_DEBUG_MISC_format__).sizeof()\n                        if data_size>0:___IMAGE_DEBUG_MISC_format__[1].append(\'{0}s,Data\'.format(data_size))\n                        dbg_type=self.__unpack_data__(___IMAGE_DEBUG_MISC_format__,dbg_type_data,dbg_type_offset)\n            elif dbg.Type==20:dbg_type_offset=dbg.PointerToRawData;dbg_type_size=dbg.SizeOfData;dbg_type_data=self.__data__[dbg_type_offset:dbg_type_offset+dbg_type_size];___IMAGE_DEBUG_EX_DLLCHARACTERISTICS_format__=[\'IMAGE_DEBUG_EX_DLLCHARACTERISTICS\',[\'I,ExDllCharacteristics\']];dbg_type=self.__unpack_data__(___IMAGE_DEBUG_EX_DLLCHARACTERISTICS_format__,dbg_type_data,dbg_type_offset);ex_dll_characteristics_flags=retrieve_flags(EX_DLL_CHARACTERISTICS,\'IMAGE_DLLCHARACTERISTICS_EX_\');set_flags(dbg_type,dbg_type.ExDllCharacteristics,ex_dll_characteristics_flags)\n            debug.append(DebugData(struct=dbg,entry=dbg_type))\n        return debug\n    def parse_resources_directory(self,rva,size=0,base_rva=None,level=0,dirs=None):\n        if dirs is None:dirs=[rva]\n        if base_rva is None:base_rva=rva\n        if level>MAX_RESOURCE_DEPTH:self.__warnings.append(\'Error parsing the resources directory. Excessively nested table depth %d (>%s)\'%(level,MAX_RESOURCE_DEPTH));return\n        try:data=self.get_data(rva,Structure(self.__IMAGE_RESOURCE_DIRECTORY_format__).sizeof())\n        except PEFormatError:self.__warnings.append("Invalid resources directory. Can\'t read directory data at RVA: 0x%x"%rva);return\n        resource_dir=self.__unpack_data__(self.__IMAGE_RESOURCE_DIRECTORY_format__,data,file_offset=self.get_offset_from_rva(rva))\n        if resource_dir is None:self.__warnings.append("Invalid resources directory. Can\'t parse directory data at RVA: 0x%x"%rva);return\n        dir_entries=[];rva+=resource_dir.sizeof();number_of_entries=resource_dir.NumberOfNamedEntries+resource_dir.NumberOfIdEntries;MAX_ALLOWED_ENTRIES=4096\n        if number_of_entries>MAX_ALLOWED_ENTRIES:self.__warnings.append(\'Error parsing the resources directory. The directory contains %d entries (>%s)\'%(number_of_entries,MAX_ALLOWED_ENTRIES));return\n        self.__total_resource_entries_count+=number_of_entries\n        if self.__total_resource_entries_count>MAX_RESOURCE_ENTRIES:self.__warnings.append(\'Error parsing the resources directory. The file contains at least %d entries (>%d)\'%(self.__total_resource_entries_count,MAX_RESOURCE_ENTRIES));return\n        strings_to_postprocess=[];last_name_begin_end=None\n        for idx in range(number_of_entries):\n            if not self.__resource_size_limit_reached and self.__total_resource_bytes>self.__resource_size_limit_upperbounds:self.__resource_size_limit_reached=True;self.__warnings.append(\'Resource size 0x%x exceeds file size 0x%x, overlapping resources found.\'%(self.__total_resource_bytes,self.__resource_size_limit_upperbounds))\n            res=self.parse_resource_entry(rva)\n            if res is None:self.__warnings.append(\'Error parsing the resources directory, Entry %d is invalid, RVA = 0x%x. \'%(idx,rva));break\n            entry_name=None;entry_id=None;name_is_string=(res.Name&2147483648)>>31\n            if not name_is_string:entry_id=res.Name\n            else:\n                ustr_offset=base_rva+res.NameOffset\n                try:\n                    entry_name=UnicodeStringWrapperPostProcessor(self,ustr_offset);self.__total_resource_bytes+=entry_name.get_pascal_16_length()\n                    if last_name_begin_end and(last_name_begin_end[0]<ustr_offset and last_name_begin_end[1]>=ustr_offset):strings_to_postprocess.pop();self.__warnings.append(\'Error parsing the resources directory, attempting to read entry name. Entry names overlap 0x%x\'%ustr_offset);break\n                    last_name_begin_end=ustr_offset,ustr_offset+entry_name.get_pascal_16_length();strings_to_postprocess.append(entry_name)\n                except PEFormatError:self.__warnings.append("Error parsing the resources directory, attempting to read entry name. Can\'t read unicode string at offset 0x%x"%ustr_offset)\n            if res.DataIsDirectory:\n                if base_rva+res.OffsetToDirectory in dirs:break\n                entry_directory=self.parse_resources_directory(base_rva+res.OffsetToDirectory,size-(rva-base_rva),base_rva=base_rva,level=level+1,dirs=dirs+[base_rva+res.OffsetToDirectory])\n                if not entry_directory:break\n                strings=None\n                if entry_id==RESOURCE_TYPE[\'RT_STRING\']:\n                    strings={}\n                    for resource_id in entry_directory.entries:\n                        if hasattr(resource_id,\'directory\'):\n                            resource_strings={}\n                            for resource_lang in resource_id.directory.entries:\n                                if resource_lang is None or not hasattr(resource_lang,\'data\')or resource_lang.data.struct.Size is None or resource_id.id is None:continue\n                                string_entry_rva=resource_lang.data.struct.OffsetToData;string_entry_size=resource_lang.data.struct.Size;string_entry_id=resource_id.id\n                                try:string_entry_data=self.get_data(string_entry_rva,string_entry_size)\n                                except PEFormatError:self.__warnings.append(f"Error parsing resource of type RT_STRING at RVA 0x{string_entry_rva:x} with size {string_entry_size}");continue\n                                parse_strings(string_entry_data,(int(string_entry_id)-1)*16,resource_strings);strings.update(resource_strings)\n                            resource_id.directory.strings=resource_strings\n                dir_entries.append(ResourceDirEntryData(struct=res,name=entry_name,id=entry_id,directory=entry_directory))\n            else:\n                struct=self.parse_resource_data_entry(base_rva+res.OffsetToDirectory)\n                if struct:self.__total_resource_bytes+=struct.Size;entry_data=ResourceDataEntryData(struct=struct,lang=res.Name&1023,sublang=res.Name>>10);dir_entries.append(ResourceDirEntryData(struct=res,name=entry_name,id=entry_id,data=entry_data))\n                else:break\n            if level==0 and res.Id==RESOURCE_TYPE[\'RT_VERSION\']:\n                if dir_entries:last_entry=dir_entries[-1]\n                try:version_entries=last_entry.directory.entries[0].directory.entries\n                except:pass\n                else:\n                    for version_entry in version_entries:\n                        rt_version_struct=None\n                        try:rt_version_struct=version_entry.data.struct\n                        except:pass\n                        if rt_version_struct is not None:self.parse_version_information(rt_version_struct)\n            rva+=res.sizeof()\n        string_rvas=[s.get_rva()for s in strings_to_postprocess];string_rvas.sort()\n        for(idx,s)in enumerate(strings_to_postprocess):s.render_pascal_16()\n        resource_directory_data=ResourceDirData(struct=resource_dir,entries=dir_entries);return resource_directory_data\n    def parse_resource_data_entry(self,rva):\n        try:data=self.get_data(rva,Structure(self.__IMAGE_RESOURCE_DATA_ENTRY_format__).sizeof())\n        except PEFormatError:self.__warnings.append(\'Error parsing a resource directory data entry, the RVA is invalid: 0x%x\'%rva);return\n        data_entry=self.__unpack_data__(self.__IMAGE_RESOURCE_DATA_ENTRY_format__,data,file_offset=self.get_offset_from_rva(rva));return data_entry\n    def parse_resource_entry(self,rva):\n        try:data=self.get_data(rva,Structure(self.__IMAGE_RESOURCE_DIRECTORY_ENTRY_format__).sizeof())\n        except PEFormatError:return\n        resource=self.__unpack_data__(self.__IMAGE_RESOURCE_DIRECTORY_ENTRY_format__,data,file_offset=self.get_offset_from_rva(rva))\n        if resource is None:return\n        resource.NameOffset=resource.Name&2147483647;resource.__pad=resource.Name&4294901760;resource.Id=resource.Name&65535;resource.DataIsDirectory=(resource.OffsetToData&2147483648)>>31;resource.OffsetToDirectory=resource.OffsetToData&2147483647;return resource\n    def parse_version_information(self,version_struct):\n        try:start_offset=self.get_offset_from_rva(version_struct.OffsetToData)\n        except PEFormatError:self.__warnings.append(\'Error parsing the version information, attempting to read OffsetToData with RVA: 0x{:x}\'.format(version_struct.OffsetToData));return\n        raw_data=self.__data__[start_offset:start_offset+version_struct.Size];versioninfo_struct=self.__unpack_data__(self.__VS_VERSIONINFO_format__,raw_data,file_offset=start_offset)\n        if versioninfo_struct is None:return\n        ustr_offset=version_struct.OffsetToData+versioninfo_struct.sizeof();section=self.get_section_by_rva(ustr_offset);section_end=None\n        if section:section_end=section.VirtualAddress+max(section.SizeOfRawData,section.Misc_VirtualSize)\n        versioninfo_string=None\n        try:\n            if section_end is None:versioninfo_string=self.get_string_u_at_rva(ustr_offset,encoding=\'ascii\')\n            else:versioninfo_string=self.get_string_u_at_rva(ustr_offset,section_end-ustr_offset>>1,encoding=\'ascii\')\n        except PEFormatError:self.__warnings.append("Error parsing the version information, attempting to read VS_VERSION_INFO string. Can\'t read unicode string at offset 0x%x"%ustr_offset)\n        if versioninfo_string is None:self.__warnings.append(\'Invalid VS_VERSION_INFO block: {0}\'.format(versioninfo_string));return\n        if versioninfo_string is not None and versioninfo_string!=b\'VS_VERSION_INFO\':\n            if len(versioninfo_string)>128:excerpt=versioninfo_string[:128].decode(\'ascii\');excerpt=excerpt[:excerpt.rfind(\'\\\\u\')];versioninfo_string=\'{0} ... ({1} bytes, too long to display)\'.format(excerpt,len(versioninfo_string)).encode()\n            self.__warnings.append(\'Invalid VS_VERSION_INFO block: {0}\'.format(versioninfo_string.decode(\'ascii\').replace(\'\\x00\',\'\\\\00\')));return\n        if not hasattr(self,\'VS_VERSIONINFO\'):self.VS_VERSIONINFO=[]\n        vinfo=versioninfo_struct;vinfo.Key=versioninfo_string;self.VS_VERSIONINFO.append(vinfo)\n        if versioninfo_string is None:versioninfo_string=\'\'\n        fixedfileinfo_offset=self.dword_align(versioninfo_struct.sizeof()+2*(len(versioninfo_string)+1),version_struct.OffsetToData);fixedfileinfo_struct=self.__unpack_data__(self.__VS_FIXEDFILEINFO_format__,raw_data[fixedfileinfo_offset:],file_offset=start_offset+fixedfileinfo_offset)\n        if not fixedfileinfo_struct:return\n        if not hasattr(self,\'VS_FIXEDFILEINFO\'):self.VS_FIXEDFILEINFO=[]\n        self.VS_FIXEDFILEINFO.append(fixedfileinfo_struct);stringfileinfo_offset=self.dword_align(fixedfileinfo_offset+fixedfileinfo_struct.sizeof(),version_struct.OffsetToData)\n        if not hasattr(self,\'FileInfo\'):self.FileInfo=[]\n        finfo=[]\n        while True:\n            stringfileinfo_struct=self.__unpack_data__(self.__StringFileInfo_format__,raw_data[stringfileinfo_offset:],file_offset=start_offset+stringfileinfo_offset)\n            if stringfileinfo_struct is None:self.__warnings.append(\'Error parsing StringFileInfo/VarFileInfo struct\');return\n            ustr_offset=version_struct.OffsetToData+stringfileinfo_offset+versioninfo_struct.sizeof()\n            try:stringfileinfo_string=self.get_string_u_at_rva(ustr_offset)\n            except PEFormatError:self.__warnings.append("Error parsing the version information, attempting to read StringFileInfo string. Can\'t read unicode string at offset 0x{0:x}".format(ustr_offset));break\n            stringfileinfo_struct.Key=stringfileinfo_string;finfo.append(stringfileinfo_struct)\n            if stringfileinfo_string and stringfileinfo_string.startswith(b\'StringFileInfo\'):\n                if stringfileinfo_struct.Type in(0,1)and stringfileinfo_struct.ValueLength==0:\n                    stringtable_offset=self.dword_align(stringfileinfo_offset+stringfileinfo_struct.sizeof()+2*(len(stringfileinfo_string)+1),version_struct.OffsetToData);stringfileinfo_struct.StringTable=[]\n                    while True:\n                        stringtable_struct=self.__unpack_data__(self.__StringTable_format__,raw_data[stringtable_offset:],file_offset=start_offset+stringtable_offset)\n                        if not stringtable_struct:break\n                        ustr_offset=version_struct.OffsetToData+stringtable_offset+stringtable_struct.sizeof()\n                        try:stringtable_string=self.get_string_u_at_rva(ustr_offset)\n                        except PEFormatError:self.__warnings.append("Error parsing the version information, attempting to read StringTable string. Can\'t read unicode string at offset 0x{0:x}".format(ustr_offset));break\n                        stringtable_struct.LangID=stringtable_string;stringtable_struct.entries={};stringtable_struct.entries_offsets={};stringtable_struct.entries_lengths={};stringfileinfo_struct.StringTable.append(stringtable_struct);entry_offset=self.dword_align(stringtable_offset+stringtable_struct.sizeof()+2*(len(stringtable_string)+1),version_struct.OffsetToData)\n                        while entry_offset<stringtable_offset+stringtable_struct.Length:\n                            string_struct=self.__unpack_data__(self.__String_format__,raw_data[entry_offset:],file_offset=start_offset+entry_offset)\n                            if not string_struct:break\n                            ustr_offset=version_struct.OffsetToData+entry_offset+string_struct.sizeof()\n                            try:key=self.get_string_u_at_rva(ustr_offset);key_offset=self.get_offset_from_rva(ustr_offset)\n                            except PEFormatError:self.__warnings.append("Error parsing the version information, attempting to read StringTable Key string. Can\'t read unicode string at offset 0x{0:x}".format(ustr_offset));break\n                            value_offset=self.dword_align(2*(len(key)+1)+entry_offset+string_struct.sizeof(),version_struct.OffsetToData);ustr_offset=version_struct.OffsetToData+value_offset\n                            try:value=self.get_string_u_at_rva(ustr_offset,max_length=string_struct.ValueLength);value_offset=self.get_offset_from_rva(ustr_offset)\n                            except PEFormatError:self.__warnings.append(f"Error parsing the version information, attempting to read StringTable Value string. Can\'t read unicode string at offset 0x{ustr_offset:x}");break\n                            if string_struct.Length==0:entry_offset=stringtable_offset+stringtable_struct.Length\n                            else:entry_offset=self.dword_align(string_struct.Length+entry_offset,version_struct.OffsetToData)\n                            stringtable_struct.entries[key]=value;stringtable_struct.entries_offsets[key]=key_offset,value_offset;stringtable_struct.entries_lengths[key]=len(key),len(value)\n                        new_stringtable_offset=self.dword_align(stringtable_struct.Length+stringtable_offset,version_struct.OffsetToData)\n                        if new_stringtable_offset==stringtable_offset:break\n                        stringtable_offset=new_stringtable_offset\n                        if stringtable_offset>=stringfileinfo_struct.Length:break\n            elif stringfileinfo_string and stringfileinfo_string.startswith(b\'VarFileInfo\'):\n                varfileinfo_struct=stringfileinfo_struct;varfileinfo_struct.name=\'VarFileInfo\'\n                if varfileinfo_struct.Type in(0,1)and varfileinfo_struct.ValueLength==0:\n                    var_offset=self.dword_align(stringfileinfo_offset+varfileinfo_struct.sizeof()+2*(len(stringfileinfo_string)+1),version_struct.OffsetToData);varfileinfo_struct.Var=[]\n                    while True:\n                        var_struct=self.__unpack_data__(self.__Var_format__,raw_data[var_offset:],file_offset=start_offset+var_offset)\n                        if not var_struct:break\n                        ustr_offset=version_struct.OffsetToData+var_offset+var_struct.sizeof()\n                        try:var_string=self.get_string_u_at_rva(ustr_offset)\n                        except PEFormatError:self.__warnings.append("Error parsing the version information, attempting to read VarFileInfo Var string. Can\'t read unicode string at offset 0x{0:x}".format(ustr_offset));break\n                        if var_string is None:break\n                        varfileinfo_struct.Var.append(var_struct);varword_offset=self.dword_align(2*(len(var_string)+1)+var_offset+var_struct.sizeof(),version_struct.OffsetToData);orig_varword_offset=varword_offset\n                        while varword_offset<orig_varword_offset+var_struct.ValueLength:\n                            word1=self.get_word_from_data(raw_data[varword_offset:varword_offset+2],0);word2=self.get_word_from_data(raw_data[varword_offset+2:varword_offset+4],0);varword_offset+=4\n                            if isinstance(word1,int)and isinstance(word2,int):var_struct.entry={var_string:\'0x%04x 0x%04x\'%(word1,word2)}\n                        var_offset=self.dword_align(var_offset+var_struct.Length,version_struct.OffsetToData)\n                        if var_offset<=var_offset+var_struct.Length:break\n            stringfileinfo_offset=self.dword_align(stringfileinfo_struct.Length+stringfileinfo_offset,version_struct.OffsetToData)\n            if stringfileinfo_struct.Length==0 or stringfileinfo_offset>=versioninfo_struct.Length:break\n        self.FileInfo.append(finfo)\n    def parse_export_directory(self,rva,size,forwarded_only=False):\n        try:export_dir=self.__unpack_data__(self.__IMAGE_EXPORT_DIRECTORY_format__,self.get_data(rva,Structure(self.__IMAGE_EXPORT_DIRECTORY_format__).sizeof()),file_offset=self.get_offset_from_rva(rva))\n        except PEFormatError:self.__warnings.append(\'Error parsing export directory at RVA: 0x%x\'%rva);return\n        if not export_dir:return\n        def length_until_eof(rva):return len(self.__data__)-self.get_offset_from_rva(rva)\n        try:address_of_names=self.get_data(export_dir.AddressOfNames,min(length_until_eof(export_dir.AddressOfNames),export_dir.NumberOfNames*4));address_of_name_ordinals=self.get_data(export_dir.AddressOfNameOrdinals,min(length_until_eof(export_dir.AddressOfNameOrdinals),export_dir.NumberOfNames*4));address_of_functions=self.get_data(export_dir.AddressOfFunctions,min(length_until_eof(export_dir.AddressOfFunctions),export_dir.NumberOfFunctions*4))\n        except PEFormatError:self.__warnings.append(\'Error parsing export directory at RVA: 0x%x\'%rva);return\n        exports=[];max_failed_entries_before_giving_up=10;section=self.get_section_by_rva(export_dir.AddressOfNames);safety_boundary=len(self.__data__)\n        if section:safety_boundary=section.VirtualAddress+len(section.get_data())-export_dir.AddressOfNames\n        symbol_counts=collections.defaultdict(int);export_parsing_loop_completed_normally=True\n        for i in range(min(export_dir.NumberOfNames,int(safety_boundary/4))):\n            symbol_ordinal=self.get_word_from_data(address_of_name_ordinals,i)\n            if symbol_ordinal is not None and symbol_ordinal*4<len(address_of_functions):symbol_address=self.get_dword_from_data(address_of_functions,symbol_ordinal)\n            else:return\n            if symbol_address is None or symbol_address==0:continue\n            if symbol_address>=rva and symbol_address<rva+size:\n                forwarder_str=self.get_string_at_rva(symbol_address)\n                try:forwarder_offset=self.get_offset_from_rva(symbol_address)\n                except PEFormatError:continue\n            else:\n                if forwarded_only:continue\n                forwarder_str=None;forwarder_offset=None\n            symbol_name_address=self.get_dword_from_data(address_of_names,i)\n            if symbol_name_address is None:\n                max_failed_entries_before_giving_up-=1\n                if max_failed_entries_before_giving_up<=0:export_parsing_loop_completed_normally=False;break\n            symbol_name=self.get_string_at_rva(symbol_name_address,MAX_SYMBOL_NAME_LENGTH)\n            if not is_valid_function_name(symbol_name,relax_allowed_characters=True):export_parsing_loop_completed_normally=False;break\n            try:symbol_name_offset=self.get_offset_from_rva(symbol_name_address)\n            except PEFormatError:\n                max_failed_entries_before_giving_up-=1\n                if max_failed_entries_before_giving_up<=0:export_parsing_loop_completed_normally=False;break\n                try:symbol_name_offset=self.get_offset_from_rva(symbol_name_address)\n                except PEFormatError:\n                    max_failed_entries_before_giving_up-=1\n                    if max_failed_entries_before_giving_up<=0:export_parsing_loop_completed_normally=False;break\n                    continue\n            symbol_counts[symbol_name,symbol_address]+=1\n            if symbol_counts[symbol_name,symbol_address]>10:self.__warnings.append(f"Export directory contains more than 10 repeated entries ({symbol_name}, {symbol_address:#02x}). Assuming corrupt.");break\n            elif len(symbol_counts)>self.max_symbol_exports:self.__warnings.append(\'Export directory contains more than {} symbol entries. Assuming corrupt.\'.format(self.max_symbol_exports));break\n            exports.append(ExportData(pe=self,ordinal=export_dir.Base+symbol_ordinal,ordinal_offset=self.get_offset_from_rva(export_dir.AddressOfNameOrdinals+2*i),address=symbol_address,address_offset=self.get_offset_from_rva(export_dir.AddressOfFunctions+4*symbol_ordinal),name=symbol_name,name_offset=symbol_name_offset,forwarder=forwarder_str,forwarder_offset=forwarder_offset))\n        if not export_parsing_loop_completed_normally:self.__warnings.append(f"RVA AddressOfNames in the export directory points to an invalid address: {export_dir.AddressOfNames:x}")\n        ordinals={exp.ordinal for exp in exports};max_failed_entries_before_giving_up=10;section=self.get_section_by_rva(export_dir.AddressOfFunctions);safety_boundary=len(self.__data__)\n        if section:safety_boundary=section.VirtualAddress+len(section.get_data())-export_dir.AddressOfFunctions\n        symbol_counts=collections.defaultdict(int);export_parsing_loop_completed_normally=True\n        for idx in range(min(export_dir.NumberOfFunctions,int(safety_boundary/4))):\n            if idx+export_dir.Base not in ordinals:\n                try:symbol_address=self.get_dword_from_data(address_of_functions,idx)\n                except PEFormatError:symbol_address=None\n                if symbol_address is None:\n                    max_failed_entries_before_giving_up-=1\n                    if max_failed_entries_before_giving_up<=0:export_parsing_loop_completed_normally=False;break\n                if symbol_address==0:continue\n                if symbol_address is not None and symbol_address>=rva and symbol_address<rva+size:forwarder_str=self.get_string_at_rva(symbol_address)\n                else:forwarder_str=None\n                symbol_counts[symbol_address]+=1\n                if symbol_counts[symbol_address]>self.max_repeated_symbol:self.__warnings.append(\'Export directory contains more than {} repeated ordinal entries (0x{:x}). Assuming corrupt.\'.format(self.max_repeated_symbol,symbol_address));break\n                elif len(symbol_counts)>self.max_symbol_exports:self.__warnings.append(f"Export directory contains more than {self.max_symbol_exports} ordinal entries. Assuming corrupt.");break\n                exports.append(ExportData(ordinal=export_dir.Base+idx,address=symbol_address,name=None,forwarder=forwarder_str))\n        if not export_parsing_loop_completed_normally:self.__warnings.append(f"RVA AddressOfFunctions in the export directory points to an invalid address: {export_dir.AddressOfFunctions:x}");return\n        if not exports and export_dir.all_zeroes():return\n        return ExportDirData(struct=export_dir,symbols=exports,name=self.get_string_at_rva(export_dir.Name))\n    def dword_align(self,offset,base):return(offset+base+3&4294967292)-(base&4294967292)\n    def normalize_import_va(self,va):\n        begin_of_image=self.OPTIONAL_HEADER.ImageBase;end_of_image=self.OPTIONAL_HEADER.ImageBase+self.OPTIONAL_HEADER.SizeOfImage\n        if begin_of_image<=va<end_of_image:va-=begin_of_image\n        return va\n    def parse_delay_import_directory(self,rva,size):\n        import_descs=[];error_count=0\n        while True:\n            try:data=self.get_data(rva,Structure(self.__IMAGE_DELAY_IMPORT_DESCRIPTOR_format__).sizeof())\n            except PEFormatError:self.__warnings.append(\'Error parsing the Delay import directory at RVA: 0x%x\'%rva);break\n            file_offset=self.get_offset_from_rva(rva);import_desc=self.__unpack_data__(self.__IMAGE_DELAY_IMPORT_DESCRIPTOR_format__,data,file_offset=file_offset)\n            if not import_desc or import_desc.all_zeroes():break\n            contains_addresses=False\n            if import_desc.grAttrs==0 and self.FILE_HEADER.Machine==MACHINE_TYPE[\'IMAGE_FILE_MACHINE_I386\']:import_desc.pBoundIAT=self.normalize_import_va(import_desc.pBoundIAT);import_desc.pIAT=self.normalize_import_va(import_desc.pIAT);import_desc.pINT=self.normalize_import_va(import_desc.pINT);import_desc.pUnloadIAT=self.normalize_import_va(import_desc.pUnloadIAT);import_desc.phmod=self.normalize_import_va(import_desc.pUnloadIAT);import_desc.szName=self.normalize_import_va(import_desc.szName);contains_addresses=True\n            rva+=import_desc.sizeof();max_len=len(self.__data__)-file_offset\n            if rva>import_desc.pINT or rva>import_desc.pIAT:max_len=max(rva-import_desc.pINT,rva-import_desc.pIAT)\n            import_data=[]\n            try:import_data=self.parse_imports(import_desc.pINT,import_desc.pIAT,None,max_len,contains_addresses)\n            except PEFormatError as excp:self.__warnings.append(\'Error parsing the Delay import directory. Invalid import data at RVA: 0x{0:x} ({1})\'.format(rva,excp.value))\n            if error_count>5:self.__warnings.append(\'Too many errors parsing the Delay import directory. Invalid import data at RVA: 0x{0:x}\'.format(rva));break\n            if not import_data:error_count+=1;continue\n            if self.__total_import_symbols>MAX_IMPORT_SYMBOLS:self.__warnings.append(\'Error, too many imported symbols %d (>%s)\'%(self.__total_import_symbols,MAX_IMPORT_SYMBOLS));break\n            dll=self.get_string_at_rva(import_desc.szName,MAX_DLL_LENGTH)\n            if not is_valid_dos_filename(dll):dll=b\'*invalid*\'\n            if dll:\n                for symbol in import_data:\n                    if symbol.name is None:\n                        funcname=ordLookup(dll.lower(),symbol.ordinal)\n                        if funcname:symbol.name=funcname\n                import_descs.append(ImportDescData(struct=import_desc,imports=import_data,dll=dll))\n        return import_descs\n    def get_rich_header_hash(self,algorithm=\'md5\'):\n        if not hasattr(self,\'RICH_HEADER\')or self.RICH_HEADER is None:return\'\'\n        if algorithm==\'md5\':return md5(self.RICH_HEADER.clear_data).hexdigest()\n        elif algorithm==\'sha1\':return sha1(self.RICH_HEADER.clear_data).hexdigest()\n        elif algorithm==\'sha256\':return sha256(self.RICH_HEADER.clear_data).hexdigest()\n        elif algorithm==\'sha512\':return sha512(self.RICH_HEADER.clear_data).hexdigest()\n        raise Exception(\'Invalid hashing algorithm specified\')\n    def get_imphash(self):\n        impstrs=[];exts=[\'ocx\',\'sys\',\'dll\']\n        if not hasattr(self,\'DIRECTORY_ENTRY_IMPORT\'):return\'\'\n        for entry in self.DIRECTORY_ENTRY_IMPORT:\n            if isinstance(entry.dll,bytes):libname=entry.dll.decode().lower()\n            else:libname=entry.dll.lower()\n            parts=libname.rsplit(\'.\',1)\n            if len(parts)>1 and parts[1]in exts:libname=parts[0]\n            entry_dll_lower=entry.dll.lower()\n            for imp in entry.imports:\n                funcname=None\n                if not imp.name:\n                    funcname=ordLookup(entry_dll_lower,imp.ordinal,make_name=True)\n                    if not funcname:raise PEFormatError(f"Unable to look up ordinal {entry.dll}:{imp.ordinal:04x}")\n                else:funcname=imp.name\n                if not funcname:continue\n                if isinstance(funcname,bytes):funcname=funcname.decode()\n                impstrs.append(\'%s.%s\'%(libname.lower(),funcname.lower()))\n        return md5(\',\'.join(impstrs).encode()).hexdigest()\n    def get_exphash(self):\n        if not hasattr(self,\'DIRECTORY_ENTRY_EXPORT\'):return\'\'\n        if not hasattr(self.DIRECTORY_ENTRY_EXPORT,\'symbols\'):return\'\'\n        export_list=[e.name.decode().lower()for e in self.DIRECTORY_ENTRY_EXPORT.symbols if e and e.name is not None]\n        if len(export_list)==0:return\'\'\n        return md5(\',\'.join(export_list).encode()).hexdigest()\n    def parse_import_directory(self,rva,size,dllnames_only=False):\n        import_descs=[];error_count=0;image_import_descriptor_size=Structure(self.__IMAGE_IMPORT_DESCRIPTOR_format__).sizeof()\n        while True:\n            try:data=self.get_data(rva,image_import_descriptor_size)\n            except PEFormatError:self.__warnings.append(f"Error parsing the import directory at RVA: 0x{rva:x}");break\n            file_offset=self.get_offset_from_rva(rva);import_desc=self.__unpack_data__(self.__IMAGE_IMPORT_DESCRIPTOR_format__,data,file_offset=file_offset)\n            if not import_desc or import_desc.all_zeroes():break\n            rva+=import_desc.sizeof();max_len=len(self.__data__)-file_offset\n            if rva>import_desc.OriginalFirstThunk or rva>import_desc.FirstThunk:max_len=max(rva-import_desc.OriginalFirstThunk,rva-import_desc.FirstThunk)\n            import_data=[]\n            if not dllnames_only:\n                try:import_data=self.parse_imports(import_desc.OriginalFirstThunk,import_desc.FirstThunk,import_desc.ForwarderChain,max_length=max_len)\n                except PEFormatError as e:self.__warnings.append(f"Error parsing the import directory. Invalid Import data at RVA: 0x{rva:x} ({e.value})")\n                if error_count>5:self.__warnings.append(f"Too many errors parsing the import directory. Invalid import data at RVA: 0x{rva:x}");break\n                if not import_data:error_count+=1;continue\n            dll=self.get_string_at_rva(import_desc.Name,MAX_DLL_LENGTH)\n            if not is_valid_dos_filename(dll):dll=b\'*invalid*\'\n            if dll:\n                for symbol in import_data:\n                    if symbol.name is None:\n                        funcname=ordLookup(dll.lower(),symbol.ordinal)\n                        if funcname:symbol.name=funcname\n                import_descs.append(ImportDescData(struct=import_desc,imports=import_data,dll=dll))\n        if not dllnames_only:\n            suspicious_imports={\'LoadLibrary\',\'GetProcAddress\'};suspicious_imports_count=0;total_symbols=0\n            for imp_dll in import_descs:\n                for symbol in imp_dll.imports:\n                    for suspicious_symbol in suspicious_imports:\n                        if not symbol or not symbol.name:continue\n                        name=symbol.name\n                        if type(symbol.name)==bytes:name=symbol.name.decode(\'utf-8\')\n                        if name.startswith(suspicious_symbol):suspicious_imports_count+=1;break\n                    total_symbols+=1\n            if suspicious_imports_count==len(suspicious_imports)and total_symbols<20:self.__warnings.append(\'Imported symbols contain entries typical of packed executables.\')\n        return import_descs\n    def parse_imports(self,original_first_thunk,first_thunk,forwarder_chain,max_length=None,contains_addresses=False):\n        imported_symbols=[];ilt=self.get_import_table(original_first_thunk,max_length,contains_addresses);iat=self.get_import_table(first_thunk,max_length,contains_addresses)\n        if(not iat or len(iat)==0)and(not ilt or len(ilt)==0):self.__warnings.append(f"Damaged Import Table information. ILT and/or IAT appear to be broken. OriginalFirstThunk: 0x{original_first_thunk:x} FirstThunk: 0x{first_thunk:x}");return[]\n        table=None\n        if ilt:table=ilt\n        elif iat:table=iat\n        else:return\n        imp_offset=4;address_mask=2147483647\n        if self.PE_TYPE==OPTIONAL_HEADER_MAGIC_PE:ordinal_flag=IMAGE_ORDINAL_FLAG\n        elif self.PE_TYPE==OPTIONAL_HEADER_MAGIC_PE_PLUS:ordinal_flag=IMAGE_ORDINAL_FLAG64;imp_offset=8;address_mask=0x7fffffffffffffff\n        else:ordinal_flag=IMAGE_ORDINAL_FLAG\n        num_invalid=0\n        for(idx,tbl_entry)in enumerate(table):\n            imp_ord=None;imp_hint=None;imp_name=None;name_offset=None;hint_name_table_rva=None;import_by_ordinal=False\n            if tbl_entry.AddressOfData:\n                if tbl_entry.AddressOfData&ordinal_flag:import_by_ordinal=True;imp_ord=tbl_entry.AddressOfData&65535;imp_name=None;name_offset=None\n                else:\n                    import_by_ordinal=False\n                    try:\n                        hint_name_table_rva=tbl_entry.AddressOfData&address_mask;data=self.get_data(hint_name_table_rva,2);imp_hint=self.get_word_from_data(data,0);imp_name=self.get_string_at_rva(tbl_entry.AddressOfData+2,MAX_IMPORT_NAME_LENGTH)\n                        if not is_valid_function_name(imp_name):imp_name=b\'*invalid*\'\n                        name_offset=self.get_offset_from_rva(tbl_entry.AddressOfData+2)\n                    except PEFormatError:pass\n                thunk_offset=tbl_entry.get_file_offset();thunk_rva=self.get_rva_from_offset(thunk_offset)\n            imp_address=first_thunk+self.OPTIONAL_HEADER.ImageBase+idx*imp_offset;struct_iat=None\n            try:\n                if iat and ilt and ilt[idx].AddressOfData!=iat[idx].AddressOfData:imp_bound=iat[idx].AddressOfData;struct_iat=iat[idx]\n                else:imp_bound=None\n            except IndexError:imp_bound=None\n            if imp_ord is None and imp_name is None:raise PEFormatError(\'Invalid entries, aborting parsing.\')\n            if imp_name==b\'*invalid*\':\n                if num_invalid>1000 and num_invalid==idx:raise PEFormatError(\'Too many invalid names, aborting parsing.\')\n                num_invalid+=1;continue\n            if imp_ord or imp_name:imported_symbols.append(ImportData(pe=self,struct_table=tbl_entry,struct_iat=struct_iat,import_by_ordinal=import_by_ordinal,ordinal=imp_ord,ordinal_offset=tbl_entry.get_file_offset(),hint=imp_hint,name=imp_name,name_offset=name_offset,bound=imp_bound,address=imp_address,hint_name_table_rva=hint_name_table_rva,thunk_offset=thunk_offset,thunk_rva=thunk_rva))\n        return imported_symbols\n    def get_import_table(self,rva,max_length=None,contains_addresses=False):\n        table=[]\n        if self.PE_TYPE==OPTIONAL_HEADER_MAGIC_PE:ordinal_flag=IMAGE_ORDINAL_FLAG;format=self.__IMAGE_THUNK_DATA_format__\n        elif self.PE_TYPE==OPTIONAL_HEADER_MAGIC_PE_PLUS:ordinal_flag=IMAGE_ORDINAL_FLAG64;format=self.__IMAGE_THUNK_DATA64_format__\n        else:ordinal_flag=IMAGE_ORDINAL_FLAG;format=self.__IMAGE_THUNK_DATA_format__\n        expected_size=Structure(format).sizeof();MAX_ADDRESS_SPREAD=128*2**20;ADDR_4GB=2**32;MAX_REPEATED_ADDRESSES=15;repeated_address=0;addresses_of_data_set_64=AddressSet();addresses_of_data_set_32=AddressSet();start_rva=rva\n        while rva:\n            if max_length is not None and rva>=start_rva+max_length:self.__warnings.append(\'Error parsing the import table. Entries go beyond bounds.\');break\n            if self.__total_import_symbols>MAX_IMPORT_SYMBOLS:self.__warnings.append(\'Excessive number of imports %d (>%s)\'%(self.__total_import_symbols,MAX_IMPORT_SYMBOLS));break\n            self.__total_import_symbols+=1\n            if repeated_address>=MAX_REPEATED_ADDRESSES:return[]\n            if addresses_of_data_set_32.diff()>MAX_ADDRESS_SPREAD:return[]\n            if addresses_of_data_set_64.diff()>MAX_ADDRESS_SPREAD:return[]\n            failed=False\n            try:data=self.get_data(rva,expected_size)\n            except PEFormatError:failed=True\n            if failed or len(data)!=expected_size:self.__warnings.append(\'Error parsing the import table. Invalid data at RVA: 0x%x\'%rva);return\n            thunk_data=self.__unpack_data__(format,data,file_offset=self.get_offset_from_rva(rva))\n            if contains_addresses:thunk_data.AddressOfData=self.normalize_import_va(thunk_data.AddressOfData);thunk_data.ForwarderString=self.normalize_import_va(thunk_data.ForwarderString);thunk_data.Function=self.normalize_import_va(thunk_data.Function);thunk_data.Ordinal=self.normalize_import_va(thunk_data.Ordinal)\n            if thunk_data and thunk_data.AddressOfData>=start_rva and thunk_data.AddressOfData<=rva:self.__warnings.append(\'Error parsing the import table. AddressOfData overlaps with THUNK_DATA for THUNK at RVA 0x%x\'%rva);break\n            if thunk_data and thunk_data.AddressOfData:\n                addr_of_data=thunk_data.AddressOfData\n                if addr_of_data&ordinal_flag:\n                    if addr_of_data&2147483647>65535:return[]\n                else:\n                    if addr_of_data>=ADDR_4GB:the_set=addresses_of_data_set_64\n                    else:the_set=addresses_of_data_set_32\n                    if addr_of_data in the_set:repeated_address+=1\n                    the_set.add(addr_of_data)\n            if not thunk_data or thunk_data.all_zeroes():break\n            rva+=thunk_data.sizeof();table.append(thunk_data)\n        return table\n    def get_memory_mapped_image(self,max_virtual_address=268435456,ImageBase=None):\n        if ImageBase is not None:original_data=self.__data__;self.relocate_image(ImageBase)\n        mapped_data=self.header\n        for section in self.sections:\n            if section.Misc_VirtualSize==0 and section.SizeOfRawData==0:continue\n            srd=section.SizeOfRawData;prd=self.adjust_PointerToRawData(section.PointerToRawData);VirtualAddress_adj=self.adjust_SectionAlignment(section.VirtualAddress,self.OPTIONAL_HEADER.SectionAlignment,self.OPTIONAL_HEADER.FileAlignment)\n            if srd>len(self.__data__)or prd>len(self.__data__)or srd+prd>len(self.__data__)or VirtualAddress_adj>=max_virtual_address:continue\n            padding_length=VirtualAddress_adj-len(mapped_data)\n            if padding_length>0:mapped_data+=b\'\\x00\'*padding_length\n            elif padding_length<0:mapped_data=mapped_data[:padding_length]\n            mapped_data+=section.get_data()\n        if ImageBase is not None:self.__data__=original_data\n        return mapped_data\n    def get_resources_strings(self):\n        resources_strings=[]\n        if hasattr(self,\'DIRECTORY_ENTRY_RESOURCE\'):\n            for res_type in self.DIRECTORY_ENTRY_RESOURCE.entries:\n                if hasattr(res_type,\'directory\'):\n                    for resource_id in res_type.directory.entries:\n                        if hasattr(resource_id,\'directory\'):\n                            if hasattr(resource_id.directory,\'strings\')and resource_id.directory.strings:\n                                for res_string in list(resource_id.directory.strings.values()):resources_strings.append(res_string)\n        return resources_strings\n    def get_data(self,rva=0,length=None):\n        s=self.get_section_by_rva(rva)\n        if length is None:end=None\n        else:end=rva+length\n        if not s:\n            if rva<len(self.header):return self.header[rva:end]\n            if rva<len(self.__data__):return self.__data__[rva:end]\n            raise PEFormatError("data at RVA can\'t be fetched. Corrupt header?")\n        return s.get_data(rva,length)\n    def get_rva_from_offset(self,offset):\n        s=self.get_section_by_offset(offset)\n        if not s:\n            if self.sections:\n                lowest_rva=min([self.adjust_SectionAlignment(s.VirtualAddress,self.OPTIONAL_HEADER.SectionAlignment,self.OPTIONAL_HEADER.FileAlignment)for s in self.sections])\n                if offset<lowest_rva:return offset\n                return\n            else:return offset\n        return s.get_rva_from_offset(offset)\n    def get_offset_from_rva(self,rva):\n        s=self.get_section_by_rva(rva)\n        if not s:\n            if rva<len(self.__data__):return rva\n            raise PEFormatError(f"data at RVA 0x{rva:x} can\'t be fetched")\n        return s.get_offset_from_rva(rva)\n    def get_string_at_rva(self,rva,max_length=MAX_STRING_LENGTH):\n        if rva is None:return\n        s=self.get_section_by_rva(rva)\n        if not s:return self.get_string_from_data(0,self.__data__[rva:rva+max_length])\n        return self.get_string_from_data(0,s.get_data(rva,length=max_length))\n    def get_bytes_from_data(self,offset,data):\n        if offset>len(data):return b\'\'\n        d=data[offset:]\n        if isinstance(d,bytearray):return bytes(d)\n        return d\n    def get_string_from_data(self,offset,data):\n        s=self.get_bytes_from_data(offset,data);end=s.find(b\'\\x00\')\n        if end>=0:s=s[:end]\n        return s\n    def get_string_u_at_rva(self,rva,max_length=2**16,encoding=None):\n        if max_length==0:return b\'\'\n        data=self.get_data(rva,2);max_length<<=1;requested=min(max_length,256);data=self.get_data(rva,requested);null_index=-1\n        while True:\n            null_index=data.find(b\'\\x00\\x00\',null_index+1)\n            if null_index==-1:\n                data_length=len(data)\n                if data_length<requested or data_length==max_length:null_index=len(data)>>1;break\n                data+=self.get_data(rva+data_length,max_length-data_length);null_index=requested-1;requested=max_length\n            elif null_index%2==0:null_index>>=1;break\n        uchrs=struct.unpack(\'<{:d}H\'.format(null_index),data[:null_index*2]);s=\'\'.join(map(chr,uchrs))\n        if encoding:return s.encode(encoding,\'backslashreplace_\')\n        return s.encode(\'utf-8\',\'backslashreplace_\')\n    def get_section_by_offset(self,offset):\n        for section in self.sections:\n            if section.contains_offset(offset):return section\n    def get_section_by_rva(self,rva):\n        if self._get_section_by_rva_last_used is not None:\n            if self._get_section_by_rva_last_used.contains_rva(rva):return self._get_section_by_rva_last_used\n        for section in self.sections:\n            if section.contains_rva(rva):self._get_section_by_rva_last_used=section;return section\n    def __str__(self):return self.dump_info()\n    def has_relocs(self):return hasattr(self,\'DIRECTORY_ENTRY_BASERELOC\')\n    def has_dynamic_relocs(self):\n        if hasattr(self,\'DIRECTORY_ENTRY_LOAD_CONFIG\'):\n            if self.DIRECTORY_ENTRY_LOAD_CONFIG.dynamic_relocations:return True\n        return False\n    def print_info(self,encoding=\'utf-8\'):print(self.dump_info(encoding=encoding))\n    def dump_info(self,dump=None,encoding=\'ascii\'):\n        if dump is None:dump=Dump()\n        warnings=self.get_warnings()\n        if warnings:\n            dump.add_header(\'Parsing Warnings\')\n            for warning in warnings:dump.add_line(warning);dump.add_newline()\n        dump.add_header(\'DOS_HEADER\');dump.add_lines(self.DOS_HEADER.dump());dump.add_newline();dump.add_header(\'NT_HEADERS\');dump.add_lines(self.NT_HEADERS.dump());dump.add_newline();dump.add_header(\'FILE_HEADER\');dump.add_lines(self.FILE_HEADER.dump());image_flags=retrieve_flags(IMAGE_CHARACTERISTICS,\'IMAGE_FILE_\');dump.add(\'Flags: \');flags=[]\n        for flag in sorted(image_flags):\n            if getattr(self.FILE_HEADER,flag[0]):flags.append(flag[0])\n        dump.add_line(\', \'.join(flags));dump.add_newline()\n        if hasattr(self,\'OPTIONAL_HEADER\')and self.OPTIONAL_HEADER is not None:dump.add_header(\'OPTIONAL_HEADER\');dump.add_lines(self.OPTIONAL_HEADER.dump())\n        dll_characteristics_flags=retrieve_flags(DLL_CHARACTERISTICS,\'IMAGE_DLLCHARACTERISTICS_\');dump.add(\'DllCharacteristics: \');flags=[]\n        for flag in sorted(dll_characteristics_flags):\n            if getattr(self.OPTIONAL_HEADER,flag[0]):flags.append(flag[0])\n        dump.add_line(\', \'.join(flags));ex_dll_characteristics_flags=retrieve_flags(EX_DLL_CHARACTERISTICS,\'IMAGE_DLLCHARACTERISTICS_EX_\')\n        if ex_dll_characteristics_flags:\n            flags=[]\n            if hasattr(self,\'DIRECTORY_ENTRY_DEBUG\')and self.DIRECTORY_ENTRY_DEBUG is not None:\n                for debug_entry in self.DIRECTORY_ENTRY_DEBUG:\n                    if debug_entry.struct.Type==DEBUG_TYPE[\'IMAGE_DEBUG_TYPE_EX_DLLCHARACTERISTICS\']:\n                        for flag in sorted(ex_dll_characteristics_flags):\n                            if getattr(debug_entry.entry,flag[0]):flags.append(flag[0])\n            if flags:dump.add(\'ExDllCharacteristics: \');dump.add_line(\', \'.join(flags))\n        dump.add_newline();dump.add_header(\'PE Sections\');section_flags=retrieve_flags(SECTION_CHARACTERISTICS,\'IMAGE_SCN_\')\n        for section in self.sections:\n            dump.add_lines(section.dump());dump.add(\'Flags: \');flags=[]\n            for flag in sorted(section_flags):\n                if getattr(section,flag[0]):flags.append(flag[0])\n            dump.add_line(\', \'.join(flags));dump.add_line(\'Entropy: {0:f} (Min=0.0, Max=8.0)\'.format(section.get_entropy()))\n            if md5 is not None:dump.add_line(\'MD5     hash: {0}\'.format(section.get_hash_md5()))\n            if sha1 is not None:dump.add_line(\'SHA-1   hash: %s\'%section.get_hash_sha1())\n            if sha256 is not None:dump.add_line(\'SHA-256 hash: %s\'%section.get_hash_sha256())\n            if sha512 is not None:dump.add_line(\'SHA-512 hash: %s\'%section.get_hash_sha512())\n            dump.add_newline()\n        if hasattr(self,\'OPTIONAL_HEADER\')and hasattr(self.OPTIONAL_HEADER,\'DATA_DIRECTORY\'):\n            dump.add_header(\'Directories\')\n            for directory in self.OPTIONAL_HEADER.DATA_DIRECTORY:\n                if directory is not None:dump.add_lines(directory.dump())\n            dump.add_newline()\n        if hasattr(self,\'VS_VERSIONINFO\'):\n            for(idx,vinfo_entry)in enumerate(self.VS_VERSIONINFO):\n                if len(self.VS_VERSIONINFO)>1:dump.add_header(f"Version Information {idx+1}")\n                else:dump.add_header(\'Version Information\')\n                if vinfo_entry is not None:dump.add_lines(vinfo_entry.dump())\n                dump.add_newline()\n                if hasattr(self,\'VS_FIXEDFILEINFO\'):dump.add_lines(self.VS_FIXEDFILEINFO[idx].dump());dump.add_newline()\n                if hasattr(self,\'FileInfo\')and len(self.FileInfo)>idx:\n                    for entry in self.FileInfo[idx]:\n                        dump.add_lines(entry.dump());dump.add_newline()\n                        if hasattr(entry,\'StringTable\'):\n                            for st_entry in entry.StringTable:\n                                [dump.add_line(\'  \'+line)for line in st_entry.dump()];dump.add_line(\'  LangID: {0}\'.format(st_entry.LangID.decode(encoding,\'backslashreplace_\')));dump.add_newline()\n                                for str_entry in sorted(list(st_entry.entries.items())):dump.add_line(\'    {0}: {1}\'.format(str_entry[0].decode(encoding,\'backslashreplace_\'),str_entry[1].decode(encoding,\'backslashreplace_\')))\n                            dump.add_newline()\n                        elif hasattr(entry,\'Var\'):\n                            for var_entry in entry.Var:\n                                if hasattr(var_entry,\'entry\'):[dump.add_line(\'  \'+line)for line in var_entry.dump()];dump.add_line(\'    {0}: {1}\'.format(list(var_entry.entry.keys())[0].decode(\'utf-8\',\'backslashreplace_\'),list(var_entry.entry.values())[0]))\n                            dump.add_newline()\n        if hasattr(self,\'DIRECTORY_ENTRY_EXPORT\'):\n            dump.add_header(\'Exported symbols\');dump.add_lines(self.DIRECTORY_ENTRY_EXPORT.struct.dump());dump.add_newline();dump.add_line(\'%-10s   %-10s  %s\'%(\'Ordinal\',\'RVA\',\'Name\'))\n            for export in self.DIRECTORY_ENTRY_EXPORT.symbols:\n                if export.address is not None:\n                    name=b\'None\'\n                    if export.name:name=export.name\n                    dump.add(\'%-10d 0x%08X    %s\'%(export.ordinal,export.address,name.decode(encoding)))\n                    if export.forwarder:dump.add_line(\' forwarder: {0}\'.format(export.forwarder.decode(encoding,\'backslashreplace_\')))\n                    else:dump.add_newline()\n            dump.add_newline()\n        if hasattr(self,\'DIRECTORY_ENTRY_IMPORT\'):\n            dump.add_header(\'Imported symbols\')\n            for module in self.DIRECTORY_ENTRY_IMPORT:\n                dump.add_lines(module.struct.dump())\n                if not module.imports:dump.add(\'  Name -> {0}\'.format(self.get_string_at_rva(module.struct.Name).decode(encoding,\'backslashreplace_\')));dump.add_newline()\n                dump.add_newline()\n                for symbol in module.imports:\n                    if symbol.bound:dump.add_line(\' Bound: 0x{0:08X}\'.format(symbol.bound))\n                    else:dump.add_newline()\n                dump.add_newline()\n        if hasattr(self,\'DIRECTORY_ENTRY_BOUND_IMPORT\'):\n            dump.add_header(\'Bound imports\')\n            for bound_imp_desc in self.DIRECTORY_ENTRY_BOUND_IMPORT:\n                dump.add_lines(bound_imp_desc.struct.dump());dump.add_line(\'DLL: {0}\'.format(bound_imp_desc.name.decode(encoding,\'backslashreplace_\')));dump.add_newline()\n                for bound_imp_ref in bound_imp_desc.entries:dump.add_lines(bound_imp_ref.struct.dump(),4);dump.add_line(\'DLL: {0}\'.format(bound_imp_ref.name.decode(encoding,\'backslashreplace_\')),4);dump.add_newline()\n        if hasattr(self,\'DIRECTORY_ENTRY_DELAY_IMPORT\'):\n            dump.add_header(\'Delay Imported symbols\')\n            for module in self.DIRECTORY_ENTRY_DELAY_IMPORT:\n                dump.add_lines(module.struct.dump());dump.add_newline()\n                for symbol in module.imports:\n                    if symbol.bound:dump.add_line(\' Bound: 0x{0:08X}\'.format(symbol.bound))\n                    else:dump.add_newline()\n                dump.add_newline()\n        if hasattr(self,\'DIRECTORY_ENTRY_RESOURCE\'):\n            dump.add_header(\'Resource directory\');dump.add_lines(self.DIRECTORY_ENTRY_RESOURCE.struct.dump())\n            for res_type in self.DIRECTORY_ENTRY_RESOURCE.entries:\n                if res_type.name is not None:name=res_type.name.decode(encoding,\'backslashreplace_\');dump.add_line(f"Name: [{name}]",2)\n                else:res_type_id=RESOURCE_TYPE.get(res_type.struct.Id,\'-\');dump.add_line(f"Id: [0x{res_type.struct.Id:X}] ({res_type_id})",2)\n                dump.add_lines(res_type.struct.dump(),2)\n                if hasattr(res_type,\'directory\'):\n                    dump.add_lines(res_type.directory.struct.dump(),4)\n                    for resource_id in res_type.directory.entries:\n                        if resource_id.name is not None:name=resource_id.name.decode(\'utf-8\',\'backslashreplace_\');dump.add_line(f"Name: [{name}]",6)\n                        else:dump.add_line(f"Id: [0x{resource_id.struct.Id:X}]",6)\n                        dump.add_lines(resource_id.struct.dump(),6)\n                        if hasattr(resource_id,\'directory\'):\n                            dump.add_lines(resource_id.directory.struct.dump(),8)\n                            for resource_lang in resource_id.directory.entries:\n                                if hasattr(resource_lang,\'data\'):dump.add_line(\'\\\\--- LANG [%d,%d][%s,%s]\'%(resource_lang.data.lang,resource_lang.data.sublang,LANG.get(resource_lang.data.lang,\'*unknown*\'),get_sublang_name_for_lang(resource_lang.data.lang,resource_lang.data.sublang)),8);dump.add_lines(resource_lang.struct.dump(),10);dump.add_lines(resource_lang.data.struct.dump(),12)\n                            if hasattr(resource_id.directory,\'strings\')and resource_id.directory.strings:\n                                dump.add_line(\'[STRINGS]\',10)\n                                for(idx,res_string)in list(sorted(resource_id.directory.strings.items())):dump.add_line(\'{0:6d}: {1}\'.format(idx,res_string.encode(\'unicode-escape\',\'backslashreplace\').decode(\'ascii\')),12)\n                dump.add_newline()\n            dump.add_newline()\n        if hasattr(self,\'DIRECTORY_ENTRY_TLS\')and self.DIRECTORY_ENTRY_TLS and self.DIRECTORY_ENTRY_TLS.struct:dump.add_header(\'TLS\');dump.add_lines(self.DIRECTORY_ENTRY_TLS.struct.dump());dump.add_newline()\n        if hasattr(self,\'DIRECTORY_ENTRY_LOAD_CONFIG\')and self.DIRECTORY_ENTRY_LOAD_CONFIG and self.DIRECTORY_ENTRY_LOAD_CONFIG.struct:dump.add_header(\'LOAD_CONFIG\');dump.add_lines(self.DIRECTORY_ENTRY_LOAD_CONFIG.struct.dump());dump.add_newline()\n        if hasattr(self,\'DIRECTORY_ENTRY_DEBUG\'):\n            dump.add_header(\'Debug information\')\n            for dbg in self.DIRECTORY_ENTRY_DEBUG:\n                dump.add_lines(dbg.struct.dump())\n                try:dump.add_line(\'Type: \'+DEBUG_TYPE[dbg.struct.Type])\n                except KeyError:dump.add_line(\'Type: 0x{0:x}(Unknown)\'.format(dbg.struct.Type))\n                dump.add_newline()\n                if dbg.entry:dump.add_lines(dbg.entry.dump(),4);dump.add_newline()\n        if self.has_relocs():\n            dump.add_header(\'Base relocations\')\n            for base_reloc in self.DIRECTORY_ENTRY_BASERELOC:\n                dump.add_lines(base_reloc.struct.dump())\n                for reloc in base_reloc.entries:\n                    try:dump.add_line(\'%08Xh %s\'%(reloc.rva,RELOCATION_TYPE[reloc.type][16:]),4)\n                    except KeyError:dump.add_line(\'0x%08X 0x%x(Unknown)\'%(reloc.rva,reloc.type),4)\n                dump.add_newline()\n        if hasattr(self,\'DIRECTORY_ENTRY_EXCEPTION\')and len(self.DIRECTORY_ENTRY_EXCEPTION)>0:\n            dump.add_header(\'Unwind data for exception handling\')\n            for rf in self.DIRECTORY_ENTRY_EXCEPTION:\n                dump.add_lines(rf.struct.dump())\n                if hasattr(rf,\'unwindinfo\')and rf.unwindinfo is not None:dump.add_lines(rf.unwindinfo.dump(),4)\n        return dump.get_text()\n    def dump_dict(self):\n        dump_dict={};warnings=self.get_warnings()\n        if warnings:dump_dict[\'Parsing Warnings\']=warnings\n        dump_dict[\'DOS_HEADER\']=self.DOS_HEADER.dump_dict();dump_dict[\'NT_HEADERS\']=self.NT_HEADERS.dump_dict();dump_dict[\'FILE_HEADER\']=self.FILE_HEADER.dump_dict();image_flags=retrieve_flags(IMAGE_CHARACTERISTICS,\'IMAGE_FILE_\');dump_dict[\'Flags\']=[]\n        for flag in image_flags:\n            if getattr(self.FILE_HEADER,flag[0]):dump_dict[\'Flags\'].append(flag[0])\n        if hasattr(self,\'OPTIONAL_HEADER\')and self.OPTIONAL_HEADER is not None:dump_dict[\'OPTIONAL_HEADER\']=self.OPTIONAL_HEADER.dump_dict()\n        dll_characteristics_flags=retrieve_flags(DLL_CHARACTERISTICS,\'IMAGE_DLLCHARACTERISTICS_\');dump_dict[\'DllCharacteristics\']=[]\n        for flag in dll_characteristics_flags:\n            if getattr(self.OPTIONAL_HEADER,flag[0]):dump_dict[\'DllCharacteristics\'].append(flag[0])\n        dump_dict[\'PE Sections\']=[];section_flags=retrieve_flags(SECTION_CHARACTERISTICS,\'IMAGE_SCN_\')\n        for section in self.sections:\n            section_dict=section.dump_dict();dump_dict[\'PE Sections\'].append(section_dict);section_dict[\'Flags\']=[]\n            for flag in section_flags:\n                if getattr(section,flag[0]):section_dict[\'Flags\'].append(flag[0])\n            section_dict[\'Entropy\']=section.get_entropy()\n            if md5 is not None:section_dict[\'MD5\']=section.get_hash_md5()\n            if sha1 is not None:section_dict[\'SHA1\']=section.get_hash_sha1()\n            if sha256 is not None:section_dict[\'SHA256\']=section.get_hash_sha256()\n            if sha512 is not None:section_dict[\'SHA512\']=section.get_hash_sha512()\n        if hasattr(self,\'OPTIONAL_HEADER\')and hasattr(self.OPTIONAL_HEADER,\'DATA_DIRECTORY\'):\n            dump_dict[\'Directories\']=[]\n            for(idx,directory)in enumerate(self.OPTIONAL_HEADER.DATA_DIRECTORY):\n                if directory is not None:dump_dict[\'Directories\'].append(directory.dump_dict())\n        if hasattr(self,\'VS_VERSIONINFO\'):\n            dump_dict[\'Version Information\']=[]\n            for(idx,vs_vinfo)in enumerate(self.VS_VERSIONINFO):\n                version_info_list=[];version_info_list.append(vs_vinfo.dump_dict())\n                if hasattr(self,\'VS_FIXEDFILEINFO\'):version_info_list.append(self.VS_FIXEDFILEINFO[idx].dump_dict())\n                if hasattr(self,\'FileInfo\')and len(self.FileInfo)>idx:\n                    fileinfo_list=[];version_info_list.append(fileinfo_list)\n                    for entry in self.FileInfo[idx]:\n                        fileinfo_list.append(entry.dump_dict())\n                        if hasattr(entry,\'StringTable\'):\n                            stringtable_dict={}\n                            for st_entry in entry.StringTable:\n                                fileinfo_list.extend(st_entry.dump_dict());stringtable_dict[\'LangID\']=st_entry.LangID\n                                for str_entry in list(st_entry.entries.items()):stringtable_dict[str_entry[0]]=str_entry[1]\n                            fileinfo_list.append(stringtable_dict)\n                        elif hasattr(entry,\'Var\'):\n                            for var_entry in entry.Var:\n                                var_dict={}\n                                if hasattr(var_entry,\'entry\'):fileinfo_list.extend(var_entry.dump_dict());var_dict[list(var_entry.entry.keys())[0]]=list(var_entry.entry.values())[0];fileinfo_list.append(var_dict)\n                dump_dict[\'Version Information\'].append(version_info_list)\n        if hasattr(self,\'DIRECTORY_ENTRY_EXPORT\'):\n            dump_dict[\'Exported symbols\']=[];dump_dict[\'Exported symbols\'].append(self.DIRECTORY_ENTRY_EXPORT.struct.dump_dict())\n            for export in self.DIRECTORY_ENTRY_EXPORT.symbols:\n                export_dict={}\n                if export.address is not None:\n                    export_dict.update({\'Ordinal\':export.ordinal,\'RVA\':export.address,\'Name\':export.name})\n                    if export.forwarder:export_dict[\'forwarder\']=export.forwarder\n                dump_dict[\'Exported symbols\'].append(export_dict)\n        if hasattr(self,\'DIRECTORY_ENTRY_IMPORT\'):\n            dump_dict[\'Imported symbols\']=[]\n            for module in self.DIRECTORY_ENTRY_IMPORT:\n                import_list=[];dump_dict[\'Imported symbols\'].append(import_list);import_list.append(module.struct.dump_dict())\n                for symbol in module.imports:\n                    symbol_dict={}\n                    if symbol.bound:symbol_dict[\'Bound\']=symbol.bound\n                    import_list.append(symbol_dict)\n        if hasattr(self,\'DIRECTORY_ENTRY_BOUND_IMPORT\'):\n            dump_dict[\'Bound imports\']=[]\n            for bound_imp_desc in self.DIRECTORY_ENTRY_BOUND_IMPORT:\n                bound_imp_desc_dict={};dump_dict[\'Bound imports\'].append(bound_imp_desc_dict);bound_imp_desc_dict.update(bound_imp_desc.struct.dump_dict());bound_imp_desc_dict[\'DLL\']=bound_imp_desc.name\n                for bound_imp_ref in bound_imp_desc.entries:bound_imp_ref_dict={};bound_imp_ref_dict.update(bound_imp_ref.struct.dump_dict());bound_imp_ref_dict[\'DLL\']=bound_imp_ref.name\n        if hasattr(self,\'DIRECTORY_ENTRY_DELAY_IMPORT\'):\n            dump_dict[\'Delay Imported symbols\']=[]\n            for module in self.DIRECTORY_ENTRY_DELAY_IMPORT:\n                module_list=[];dump_dict[\'Delay Imported symbols\'].append(module_list);module_list.append(module.struct.dump_dict())\n                for symbol in module.imports:\n                    symbol_dict={}\n                    if symbol.bound:symbol_dict[\'Bound\']=symbol.bound\n                    module_list.append(symbol_dict)\n        if hasattr(self,\'DIRECTORY_ENTRY_RESOURCE\'):\n            dump_dict[\'Resource directory\']=[];dump_dict[\'Resource directory\'].append(self.DIRECTORY_ENTRY_RESOURCE.struct.dump_dict())\n            for res_type in self.DIRECTORY_ENTRY_RESOURCE.entries:\n                resource_type_dict={}\n                if res_type.name is not None:resource_type_dict[\'Name\']=res_type.name\n                else:resource_type_dict[\'Id\']=res_type.struct.Id,RESOURCE_TYPE.get(res_type.struct.Id,\'-\')\n                resource_type_dict.update(res_type.struct.dump_dict());dump_dict[\'Resource directory\'].append(resource_type_dict)\n                if hasattr(res_type,\'directory\'):\n                    directory_list=[];directory_list.append(res_type.directory.struct.dump_dict());dump_dict[\'Resource directory\'].append(directory_list)\n                    for resource_id in res_type.directory.entries:\n                        resource_id_dict={}\n                        if resource_id.name is not None:resource_id_dict[\'Name\']=resource_id.name\n                        else:resource_id_dict[\'Id\']=resource_id.struct.Id\n                        resource_id_dict.update(resource_id.struct.dump_dict());directory_list.append(resource_id_dict)\n                        if hasattr(resource_id,\'directory\'):\n                            resource_id_list=[];resource_id_list.append(resource_id.directory.struct.dump_dict());directory_list.append(resource_id_list)\n                            for resource_lang in resource_id.directory.entries:\n                                if hasattr(resource_lang,\'data\'):resource_lang_dict={};resource_lang_dict[\'LANG\']=resource_lang.data.lang;resource_lang_dict[\'SUBLANG\']=resource_lang.data.sublang;resource_lang_dict[\'LANG_NAME\']=LANG.get(resource_lang.data.lang,\'*unknown*\');resource_lang_dict[\'SUBLANG_NAME\']=get_sublang_name_for_lang(resource_lang.data.lang,resource_lang.data.sublang);resource_lang_dict.update(resource_lang.struct.dump_dict());resource_lang_dict.update(resource_lang.data.struct.dump_dict());resource_id_list.append(resource_lang_dict)\n                            if hasattr(resource_id.directory,\'strings\')and resource_id.directory.strings:\n                                for(idx,res_string)in list(resource_id.directory.strings.items()):resource_id_list.append(res_string.encode(\'unicode-escape\',\'backslashreplace\').decode(\'ascii\'))\n        if hasattr(self,\'DIRECTORY_ENTRY_TLS\')and self.DIRECTORY_ENTRY_TLS and self.DIRECTORY_ENTRY_TLS.struct:dump_dict[\'TLS\']=self.DIRECTORY_ENTRY_TLS.struct.dump_dict()\n        if hasattr(self,\'DIRECTORY_ENTRY_LOAD_CONFIG\')and self.DIRECTORY_ENTRY_LOAD_CONFIG and self.DIRECTORY_ENTRY_LOAD_CONFIG.struct:dump_dict[\'LOAD_CONFIG\']=self.DIRECTORY_ENTRY_LOAD_CONFIG.struct.dump_dict()\n        if hasattr(self,\'DIRECTORY_ENTRY_DEBUG\'):\n            dump_dict[\'Debug information\']=[]\n            for dbg in self.DIRECTORY_ENTRY_DEBUG:dbg_dict={};dump_dict[\'Debug information\'].append(dbg_dict);dbg_dict.update(dbg.struct.dump_dict());dbg_dict[\'Type\']=DEBUG_TYPE.get(dbg.struct.Type,dbg.struct.Type)\n        if self.has_relocs():\n            dump_dict[\'Base relocations\']=[]\n            for base_reloc in self.DIRECTORY_ENTRY_BASERELOC:\n                base_reloc_list=[];dump_dict[\'Base relocations\'].append(base_reloc_list);base_reloc_list.append(base_reloc.struct.dump_dict())\n                for reloc in base_reloc.entries:\n                    reloc_dict={};base_reloc_list.append(reloc_dict);reloc_dict[\'RVA\']=reloc.rva\n                    try:reloc_dict[\'Type\']=RELOCATION_TYPE[reloc.type][16:]\n                    except KeyError:reloc_dict[\'Type\']=reloc.type\n        return dump_dict\n    def get_physical_by_rva(self,rva):\n        try:return self.get_offset_from_rva(rva)\n        except Exception:return\n    def get_data_from_dword(self,dword):return struct.pack(\'<L\',dword&4294967295)\n    def get_dword_from_data(self,data,offset):\n        if(offset+1)*4>len(data):return\n        return struct.unpack(\'<I\',data[offset*4:(offset+1)*4])[0]\n    def get_dword_at_rva(self,rva):\n        try:return self.get_dword_from_data(self.get_data(rva,4),0)\n        except PEFormatError:return\n    def get_dword_from_offset(self,offset):\n        if offset+4>len(self.__data__):return\n        return self.get_dword_from_data(self.__data__[offset:offset+4],0)\n    def set_dword_at_rva(self,rva,dword):return self.set_bytes_at_rva(rva,self.get_data_from_dword(dword))\n    def set_dword_at_offset(self,offset,dword):return self.set_bytes_at_offset(offset,self.get_data_from_dword(dword))\n    def get_data_from_word(self,word):return struct.pack(\'<H\',word)\n    def get_word_from_data(self,data,offset):\n        if(offset+1)*2>len(data):return\n        return struct.unpack(\'<H\',data[offset*2:(offset+1)*2])[0]\n    def get_word_at_rva(self,rva):\n        try:return self.get_word_from_data(self.get_data(rva)[:2],0)\n        except PEFormatError:return\n    def get_word_from_offset(self,offset):\n        if offset+2>len(self.__data__):return\n        return self.get_word_from_data(self.__data__[offset:offset+2],0)\n    def set_word_at_rva(self,rva,word):return self.set_bytes_at_rva(rva,self.get_data_from_word(word))\n    def set_word_at_offset(self,offset,word):return self.set_bytes_at_offset(offset,self.get_data_from_word(word))\n    def get_data_from_qword(self,word):return struct.pack(\'<Q\',word)\n    def get_qword_from_data(self,data,offset):\n        if(offset+1)*8>len(data):return\n        return struct.unpack(\'<Q\',data[offset*8:(offset+1)*8])[0]\n    def get_qword_at_rva(self,rva):\n        try:return self.get_qword_from_data(self.get_data(rva)[:8],0)\n        except PEFormatError:return\n    def get_qword_from_offset(self,offset):\n        if offset+8>len(self.__data__):return\n        return self.get_qword_from_data(self.__data__[offset:offset+8],0)\n    def set_qword_at_rva(self,rva,qword):return self.set_bytes_at_rva(rva,self.get_data_from_qword(qword))\n    def set_qword_at_offset(self,offset,qword):return self.set_bytes_at_offset(offset,self.get_data_from_qword(qword))\n    def set_bytes_at_rva(self,rva,data):\n        if not isinstance(data,bytes):raise TypeError(\'data should be of type: bytes\')\n        offset=self.get_physical_by_rva(rva)\n        if not offset:return False\n        return self.set_bytes_at_offset(offset,data)\n    def set_bytes_at_offset(self,offset,data):\n        if not isinstance(data,bytes):raise TypeError(\'data should be of type: bytes\')\n        if 0<=offset<len(self.__data__):self.set_data_bytes(offset,data)\n        else:return False\n        return True\n    def set_data_bytes(self,offset,data):\n        if not isinstance(self.__data__,bytearray):new_data=bytearray(self.__data__);self._close_data();self.__data__=new_data\n        self.__data__[offset:offset+len(data)]=data\n    def merge_modified_section_data(self):\n        for section in self.sections:\n            section_data_start=self.adjust_PointerToRawData(section.PointerToRawData);section_data_end=section_data_start+section.SizeOfRawData\n            if section_data_start<len(self.__data__)and section_data_end<len(self.__data__):self.set_data_bytes(section_data_start,section.get_data())\n    def relocate_image(self,new_ImageBase):\n        relocation_difference=new_ImageBase-self.OPTIONAL_HEADER.ImageBase\n        if len(self.OPTIONAL_HEADER.DATA_DIRECTORY)>=6 and self.OPTIONAL_HEADER.DATA_DIRECTORY[5].Size:\n            if not hasattr(self,\'DIRECTORY_ENTRY_BASERELOC\'):self.parse_data_directories(directories=[DIRECTORY_ENTRY[\'IMAGE_DIRECTORY_ENTRY_BASERELOC\']])\n            if not hasattr(self,\'DIRECTORY_ENTRY_BASERELOC\'):self.__warnings.append(\'Relocating image but PE does not have (or pefile cannot parse) a DIRECTORY_ENTRY_BASERELOC\')\n            else:\n                for reloc in self.DIRECTORY_ENTRY_BASERELOC:\n                    entry_idx=0\n                    while entry_idx<len(reloc.entries):\n                        entry=reloc.entries[entry_idx];entry_idx+=1\n                        if entry.type==RELOCATION_TYPE[\'IMAGE_REL_BASED_ABSOLUTE\']:0\n                        elif entry.type==RELOCATION_TYPE[\'IMAGE_REL_BASED_HIGH\']:self.set_word_at_rva(entry.rva,self.get_word_at_rva(entry.rva)+relocation_difference>>16&65535)\n                        elif entry.type==RELOCATION_TYPE[\'IMAGE_REL_BASED_LOW\']:self.set_word_at_rva(entry.rva,self.get_word_at_rva(entry.rva)+relocation_difference&65535)\n                        elif entry.type==RELOCATION_TYPE[\'IMAGE_REL_BASED_HIGHLOW\']:self.set_dword_at_rva(entry.rva,self.get_dword_at_rva(entry.rva)+relocation_difference)\n                        elif entry.type==RELOCATION_TYPE[\'IMAGE_REL_BASED_HIGHADJ\']:\n                            if entry_idx==len(reloc.entries):break\n                            next_entry=reloc.entries[entry_idx];entry_idx+=1;self.set_word_at_rva(entry.rva,((self.get_word_at_rva(entry.rva)<<16)+next_entry.rva+relocation_difference&4294901760)>>16)\n                        elif entry.type==RELOCATION_TYPE[\'IMAGE_REL_BASED_DIR64\']:self.set_qword_at_rva(entry.rva,self.get_qword_at_rva(entry.rva)+relocation_difference)\n            self.OPTIONAL_HEADER.ImageBase=new_ImageBase\n            if hasattr(self,\'DIRECTORY_ENTRY_IMPORT\'):\n                for dll in self.DIRECTORY_ENTRY_IMPORT:\n                    for func in dll.imports:func.address+=relocation_difference\n            if hasattr(self,\'DIRECTORY_ENTRY_TLS\'):self.DIRECTORY_ENTRY_TLS.struct.StartAddressOfRawData+=relocation_difference;self.DIRECTORY_ENTRY_TLS.struct.EndAddressOfRawData+=relocation_difference;self.DIRECTORY_ENTRY_TLS.struct.AddressOfIndex+=relocation_difference;self.DIRECTORY_ENTRY_TLS.struct.AddressOfCallBacks+=relocation_difference\n            if hasattr(self,\'DIRECTORY_ENTRY_LOAD_CONFIG\'):\n                load_config=self.DIRECTORY_ENTRY_LOAD_CONFIG.struct\n                if hasattr(load_config,\'LockPrefixTable\')and load_config.LockPrefixTable:load_config.LockPrefixTable+=relocation_difference\n                if hasattr(load_config,\'EditList\')and load_config.EditList:load_config.EditList+=relocation_difference\n                if hasattr(load_config,\'SecurityCookie\')and load_config.SecurityCookie:load_config.SecurityCookie+=relocation_difference\n                if hasattr(load_config,\'SEHandlerTable\')and load_config.SEHandlerTable:load_config.SEHandlerTable+=relocation_difference\n                if hasattr(load_config,\'GuardCFCheckFunctionPointer\')and load_config.GuardCFCheckFunctionPointer:load_config.GuardCFCheckFunctionPointer+=relocation_difference\n                if hasattr(load_config,\'GuardCFDispatchFunctionPointer\')and load_config.GuardCFDispatchFunctionPointer:load_config.GuardCFDispatchFunctionPointer+=relocation_difference\n                if hasattr(load_config,\'GuardCFFunctionTable\')and load_config.GuardCFFunctionTable:load_config.GuardCFFunctionTable+=relocation_difference\n                if hasattr(load_config,\'GuardAddressTakenIatEntryTable\')and load_config.GuardAddressTakenIatEntryTable:load_config.GuardAddressTakenIatEntryTable+=relocation_difference\n                if hasattr(load_config,\'GuardLongJumpTargetTable\')and load_config.GuardLongJumpTargetTable:load_config.GuardLongJumpTargetTable+=relocation_difference\n                if hasattr(load_config,\'DynamicValueRelocTable\')and load_config.DynamicValueRelocTable:load_config.DynamicValueRelocTable+=relocation_difference\n                if self.PE_TYPE==OPTIONAL_HEADER_MAGIC_PE_PLUS and hasattr(load_config,\'CHPEMetadataPointer\')and load_config.CHPEMetadataPointer:load_config.CHPEMetadataPointer+=relocation_difference\n                if hasattr(load_config,\'GuardRFFailureRoutine\')and load_config.GuardRFFailureRoutine:load_config.GuardRFFailureRoutine+=relocation_difference\n                if hasattr(load_config,\'GuardRFFailureRoutineFunctionPointer\')and load_config.GuardRFFailureRoutineFunctionPointer:load_config.GuardRFVerifyStackPointerFunctionPointer+=relocation_difference\n                if hasattr(load_config,\'GuardRFVerifyStackPointerFunctionPointer\')and load_config.GuardRFVerifyStackPointerFunctionPointer:load_config.GuardRFVerifyStackPointerFunctionPointer+=relocation_difference\n                if hasattr(load_config,\'EnclaveConfigurationPointer\')and load_config.EnclaveConfigurationPointer:load_config.EnclaveConfigurationPointer+=relocation_difference\n                if hasattr(load_config,\'VolatileMetadataPointer\')and load_config.VolatileMetadataPointer:load_config.VolatileMetadataPointer+=relocation_difference\n                if hasattr(load_config,\'GuardEHContinuationTable\')and load_config.GuardEHContinuationTable:load_config.GuardEHContinuationTable+=relocation_difference\n                if hasattr(load_config,\'GuardXFGCheckFunctionPointer\')and load_config.GuardXFGCheckFunctionPointer:load_config.GuardXFGCheckFunctionPointer+=relocation_difference\n                if hasattr(load_config,\'GuardXFGDispatchFunctionPointer\')and load_config.GuardXFGDispatchFunctionPointer:load_config.GuardXFGDispatchFunctionPointer+=relocation_difference\n                if hasattr(load_config,\'GuardXFGTableDispatchFunctionPointer\')and load_config.GuardXFGTableDispatchFunctionPointer:load_config.GuardXFGTableDispatchFunctionPointer+=relocation_difference\n                if hasattr(load_config,\'CastGuardOsDeterminedFailureMode\')and load_config.CastGuardOsDeterminedFailureMode:load_config.CastGuardOsDeterminedFailureMode+=relocation_difference\n                if hasattr(load_config,\'GuardMemcpyFunctionPointer\')and load_config.GuardMemcpyFunctionPointer:load_config.GuardMemcpyFunctionPointer+=relocation_difference\n    def verify_checksum(self):return self.OPTIONAL_HEADER.CheckSum==self.generate_checksum()\n    def generate_checksum(self):\n        new_data=self.write();self._close_data();self.__data__=new_data;checksum_offset=self.OPTIONAL_HEADER.get_file_offset()+64;checksum=0;remainder=len(self.__data__)%4;data_len=len(self.__data__)+(4-remainder)*(remainder!=0)\n        for i in range(data_len//4):\n            if i==checksum_offset//4:continue\n            if i+1==data_len//4 and remainder:dword=struct.unpack(\'I\',self.__data__[i*4:]+b\'\\x00\'*(4-remainder))[0]\n            else:dword=struct.unpack(\'I\',self.__data__[i*4:i*4+4])[0]\n            checksum+=dword\n            if checksum>=2**32:checksum=(checksum&4294967295)+(checksum>>32)\n        checksum=(checksum&65535)+(checksum>>16);checksum=checksum+(checksum>>16);checksum=checksum&65535;return checksum+len(self.__data__)\n    def is_exe(self):\n        EXE_flag=IMAGE_CHARACTERISTICS[\'IMAGE_FILE_EXECUTABLE_IMAGE\']\n        if not self.is_dll()and not self.is_driver()and EXE_flag&self.FILE_HEADER.Characteristics==EXE_flag:return True\n        return False\n    def is_dll(self):\n        DLL_flag=IMAGE_CHARACTERISTICS[\'IMAGE_FILE_DLL\']\n        if DLL_flag&self.FILE_HEADER.Characteristics==DLL_flag:return True\n        return False\n    def is_driver(self):\n        if not hasattr(self,\'DIRECTORY_ENTRY_IMPORT\'):self.parse_data_directories(directories=[DIRECTORY_ENTRY[\'IMAGE_DIRECTORY_ENTRY_IMPORT\']])\n        if not hasattr(self,\'DIRECTORY_ENTRY_IMPORT\'):return False\n        system_DLLs={b\'ntoskrnl.exe\',b\'hal.dll\',b\'ndis.sys\',b\'bootvid.dll\',b\'kdcom.dll\'}\n        if system_DLLs.intersection({imp.dll.lower()for imp in self.DIRECTORY_ENTRY_IMPORT}):return True\n        driver_like_section_names={b\'page\',b\'paged\'}\n        if driver_like_section_names.intersection({section.Name.lower().rstrip(b\'\\x00\')for section in self.sections})and self.OPTIONAL_HEADER.Subsystem in(SUBSYSTEM_TYPE[\'IMAGE_SUBSYSTEM_NATIVE\'],SUBSYSTEM_TYPE[\'IMAGE_SUBSYSTEM_NATIVE_WINDOWS\']):return True\n        return False\n    def get_overlay_data_start_offset(self):\n        largest_offset_and_size=0,0\n        def update_if_sum_is_larger_and_within_file(offset_and_size,file_size=len(self.__data__)):\n            if sum(largest_offset_and_size)<sum(offset_and_size)<=file_size:return offset_and_size\n            return largest_offset_and_size\n        if hasattr(self,\'OPTIONAL_HEADER\'):largest_offset_and_size=update_if_sum_is_larger_and_within_file((self.OPTIONAL_HEADER.get_file_offset(),self.FILE_HEADER.SizeOfOptionalHeader))\n        for section in self.sections:largest_offset_and_size=update_if_sum_is_larger_and_within_file((section.PointerToRawData,section.SizeOfRawData))\n        skip_directories=[DIRECTORY_ENTRY[\'IMAGE_DIRECTORY_ENTRY_SECURITY\']]\n        for(idx,directory)in enumerate(self.OPTIONAL_HEADER.DATA_DIRECTORY):\n            if idx in skip_directories:continue\n            try:largest_offset_and_size=update_if_sum_is_larger_and_within_file((self.get_offset_from_rva(directory.VirtualAddress),directory.Size))\n            except PEFormatError:continue\n        if len(self.__data__)>sum(largest_offset_and_size):return sum(largest_offset_and_size)\n    def get_overlay(self):\n        overlay_data_offset=self.get_overlay_data_start_offset()\n        if overlay_data_offset is not None:return self.__data__[overlay_data_offset:]\n    def trim(self):\n        overlay_data_offset=self.get_overlay_data_start_offset()\n        if overlay_data_offset is not None:return self.__data__[:overlay_data_offset]\n        return self.__data__[:]\n    def adjust_PointerToRawData(self,val):\n        if self.OPTIONAL_HEADER.FileAlignment>=MIN_VALID_FILE_ALIGNMENT:\n            if self.FileAlignment_Warning is False and not power_of_two(self.OPTIONAL_HEADER.FileAlignment):self.__warnings.append(\'If FileAlignment > 0x200 it should be a power of 2. Value: %x\'%self.OPTIONAL_HEADER.FileAlignment);self.FileAlignment_Warning=True\n        return val&~511\n    def adjust_SectionAlignment(self,val,section_alignment,file_alignment):\n        if section_alignment<4096:\n            if file_alignment!=section_alignment and self.SectionAlignment_Warning is False:self.__warnings.append(f"If SectionAlignment(0x{section_alignment:x}) < 0x1000 it should equal FileAlignment(0x{file_alignment:x})");self.SectionAlignment_Warning=True\n        return cache_adjust_SectionAlignment(val,section_alignment,file_alignment)\n\n"""\n\n######################################################################################           ######################################################################################\n###################################################################################### PEFILE.PY ######################################################################################\n######################################################################################           ######################################################################################\n\n"""\n\n# System DLLs\n_kernel32 = ctypes.WinDLL(\'kernel32\')\n_msvcrt = ctypes.CDLL(\'msvcrt\')\n\n# Check if the current machine is x64 or x86\nIS_X64 = ctypes.sizeof(ctypes.c_void_p) == ctypes.sizeof(ctypes.c_ulonglong)\n\n# Type declarations\nPWORD = ctypes.POINTER(wintypes.WORD)\nPDWORD = ctypes.POINTER(wintypes.DWORD)\nPHMODULE = ctypes.POINTER(wintypes.HMODULE)\nLONG_PTR = ctypes.c_longlong if IS_X64 else wintypes.LONG\nULONG_PTR2 = ctypes.c_ulong\nULONG_PTR = ctypes.c_ulonglong if IS_X64 else wintypes.DWORD\nUINT_PTR = ctypes.c_ulonglong if IS_X64 else ctypes.c_uint\nSIZE_T = ULONG_PTR\nPOINTER_TYPE = ULONG_PTR\nPOINTER_TYPE2 = ULONG_PTR2\nLP_POINTER_TYPE = ctypes.POINTER(POINTER_TYPE)\nFARPROC = ctypes.CFUNCTYPE(None)\nPFARPROC = ctypes.POINTER(FARPROC)\nc_uchar_p = ctypes.POINTER(ctypes.c_ubyte)\nc_ushort_p = ctypes.POINTER(ctypes.c_ushort)\n\n# Generic Constants\nNULL = 0\n\n# Win32/Module-specific constants\nIMAGE_SIZEOF_SHORT_NAME = 8\nIMAGE_NUMBEROF_DIRECTORY_ENTRIES = 16\nIMAGE_SIZEOF_SECTION_HEADER = 40\n\n# Struct declarations\nclass IMAGE_SECTION_HEADER_MISC(ctypes.Union):\n    _fields_ = [\n        (\'PhysicalAddress\', wintypes.DWORD),\n        (\'VirtualSize\', wintypes.DWORD),\n    ]\n\n\nclass IMAGE_SECTION_HEADER(ctypes.Structure):\n    _anonymous_ = (\'Misc\',)\n    _fields_ = [\n        (\'Name\', wintypes.BYTE * IMAGE_SIZEOF_SHORT_NAME),\n        (\'Misc\', IMAGE_SECTION_HEADER_MISC),\n        (\'VirtualAddress\', wintypes.DWORD),\n        (\'SizeOfRawData\', wintypes.DWORD),\n        (\'PointerToRawData\', wintypes.DWORD),\n        (\'PointerToRelocations\', wintypes.DWORD),\n        (\'PointerToLinenumbers\', wintypes.DWORD),\n        (\'NumberOfRelocations\', wintypes.WORD),\n        (\'NumberOfLinenumbers\', wintypes.WORD),\n        (\'Characteristics\', wintypes.DWORD),\n    ]\n\n\nPIMAGE_SECTION_HEADER = ctypes.POINTER(IMAGE_SECTION_HEADER)\n\n\nclass IMAGE_DOS_HEADER(ctypes.Structure):\n    _fields_ = [\n        (\'e_magic\', wintypes.WORD),\n        (\'e_cblp\', wintypes.WORD),\n        (\'e_cp\', wintypes.WORD),\n        (\'e_crlc\', wintypes.WORD),\n        (\'e_cparhdr\', wintypes.WORD),\n        (\'e_minalloc\', wintypes.WORD),\n        (\'e_maxalloc\', wintypes.WORD),\n        (\'e_ss\', wintypes.WORD),\n        (\'e_sp\', wintypes.WORD),\n        (\'e_csum\', wintypes.WORD),\n        (\'e_ip\', wintypes.WORD),\n        (\'e_cs\', wintypes.WORD),\n        (\'e_lfarlc\', wintypes.WORD),\n        (\'e_ovno\', wintypes.WORD),\n        (\'e_res\', wintypes.WORD * 4),\n        (\'e_oemid\', wintypes.WORD),\n        (\'e_oeminfo\', wintypes.WORD),\n        (\'e_res2\', wintypes.WORD * 10),\n        (\'e_lfanew\', wintypes.LONG),\n    ]\n\n\nPIMAGE_DOS_HEADER = ctypes.POINTER(IMAGE_DOS_HEADER)\n\n\nclass IMAGE_TLS_CALLBACK(ctypes.c_void_p):\n    """void NTAPI IMAGE_TLS_CALLBACK(PVOID DllHandle, DWORD Reason, PVOID Reserved)"""\n\n\nPIMAGE_TLS_CALLBACK = ctypes.POINTER(IMAGE_TLS_CALLBACK)\n\n\nclass IMAGE_TLS_DIRECTORY(ctypes.Structure):\n    _fields_ = [\n        (\'StartAddressOfRawData\', ctypes.c_ulonglong),\n        (\'EndAddressOfRawData\', ctypes.c_ulonglong),\n        (\'AddressOfIndex\', ctypes.c_ulonglong),\n        (\'AddressOfCallBacks\', ctypes.c_ulonglong),\n        (\'SizeOfZeroFill\', wintypes.DWORD),\n        (\'Characteristics\', wintypes.DWORD),\n    ]\n\n\nPIMAGE_TLS_DIRECTORY = ctypes.POINTER(IMAGE_TLS_DIRECTORY)\n\n\nclass IMAGE_DATA_DIRECTORY(ctypes.Structure):\n    _fields_ = [\n        (\'VirtualAddress\', wintypes.DWORD),\n        (\'Size\', wintypes.DWORD),\n    ]\n\n\nPIMAGE_DATA_DIRECTORY = ctypes.POINTER(IMAGE_DATA_DIRECTORY)\n\n\nclass IMAGE_BASE_RELOCATION(ctypes.Structure):\n    _fields_ = [\n        (\'VirtualAddress\', wintypes.DWORD),\n        (\'SizeOfBlock\', wintypes.DWORD),\n    ]\n\n\nPIMAGE_BASE_RELOCATION = ctypes.POINTER(IMAGE_BASE_RELOCATION)\n\n\nclass IMAGE_EXPORT_DIRECTORY(ctypes.Structure):\n    _fields_ = [\n        (\'Characteristics\', wintypes.DWORD),\n        (\'TimeDateStamp\', wintypes.DWORD),\n        (\'MajorVersion\', wintypes.WORD),\n        (\'MinorVersion\', wintypes.WORD),\n        (\'Name\', wintypes.DWORD),\n        (\'Base\', wintypes.DWORD),\n        (\'NumberOfFunctions\', wintypes.DWORD),\n        (\'NumberOfNames\', wintypes.DWORD),\n        (\'AddressOfFunctions\', wintypes.DWORD),\n        (\'AddressOfNames\', wintypes.DWORD),\n        (\'AddressOfNamesOrdinals\', wintypes.DWORD),\n    ]\n\n\nPIMAGE_EXPORT_DIRECTORY = ctypes.POINTER(IMAGE_EXPORT_DIRECTORY)\n\n\nclass IMAGE_IMPORT_DESCRIPTOR_START(ctypes.Union):\n    _fields_ = [\n        (\'Characteristics\', wintypes.DWORD),\n        (\'OriginalFirstThunk\', wintypes.DWORD),\n    ]\n\n\nclass IMAGE_IMPORT_DESCRIPTOR(ctypes.Structure):\n    _anonymous_ = (\'DUMMY\',)\n    _fields_ = [\n        (\'DUMMY\', IMAGE_IMPORT_DESCRIPTOR_START),\n        (\'TimeDateStamp\', wintypes.DWORD),\n        (\'ForwarderChain\', wintypes.DWORD),\n        (\'Name\', wintypes.DWORD),\n        (\'FirstThunk\', wintypes.DWORD),\n    ]\n\n\nPIMAGE_IMPORT_DESCRIPTOR = ctypes.POINTER(IMAGE_IMPORT_DESCRIPTOR)\n\n\nclass IMAGE_IMPORT_BY_NAME(ctypes.Structure):\n    _fields_ = [\n        (\'Hint\', wintypes.WORD),\n        (\'Name\', ctypes.ARRAY(wintypes.BYTE, 1)),\n    ]\n\n\nPIMAGE_IMPORT_BY_NAME = ctypes.POINTER(IMAGE_IMPORT_BY_NAME)\n\n\nclass IMAGE_OPTIONAL_HEADER(ctypes.Structure):\n    _fields_ = [\n        (\'Magic\', wintypes.WORD),\n        (\'MajorLinkerVersion\', wintypes.BYTE),\n        (\'MinorLinkerVersion\', wintypes.BYTE),\n        (\'SizeOfCode\', wintypes.DWORD),\n        (\'SizeOfInitializedData\', wintypes.DWORD),\n        (\'SizeOfUninitializedData\', wintypes.DWORD),\n        (\'AddressOfEntryPoint\', wintypes.DWORD),\n        (\'BaseOfCode\', wintypes.DWORD),\n        (\'BaseOfData\', wintypes.DWORD),\n        (\'ImageBase\', POINTER_TYPE),\n        (\'SectionAlignment\', wintypes.DWORD),\n        (\'FileAlignment\', wintypes.DWORD),\n        (\'MajorOperatingSystemVersion\', wintypes.WORD),\n        (\'MinorOperatingSystemVersion\', wintypes.WORD),\n        (\'MajorImageVersion\', wintypes.WORD),\n        (\'MinorImageVersion\', wintypes.WORD),\n        (\'MajorSubsystemVersion\', wintypes.WORD),\n        (\'MinorSubsystemVersion\', wintypes.WORD),\n        (\'Reserved1\', wintypes.DWORD),\n        (\'SizeOfImage\', wintypes.DWORD),\n        (\'SizeOfHeaders\', wintypes.DWORD),\n        (\'CheckSum\', wintypes.DWORD),\n        (\'Subsystem\', wintypes.WORD),\n        (\'DllCharacteristics\', wintypes.WORD),\n        (\'SizeOfStackReserve\', POINTER_TYPE),\n        (\'SizeOfStackCommit\', POINTER_TYPE),\n        (\'SizeOfHeapReserve\', POINTER_TYPE),\n        (\'SizeOfHeapCommit\', POINTER_TYPE),\n        (\'LoaderFlags\', wintypes.DWORD),\n        (\'NumberOfRvaAndSizes\', wintypes.DWORD),\n        (\'DataDirectory\', IMAGE_DATA_DIRECTORY * IMAGE_NUMBEROF_DIRECTORY_ENTRIES),\n    ]\n\n\nPIMAGE_OPTIONAL_HEADER = ctypes.POINTER(IMAGE_OPTIONAL_HEADER)\n\n\nclass IMAGE_FILE_HEADER(ctypes.Structure):\n    _fields_ = [\n        (\'Machine\', wintypes.WORD),\n        (\'NumberOfSections\', wintypes.WORD),\n        (\'TimeDateStamp\', wintypes.DWORD),\n        (\'PointerToSymbolTable\', wintypes.DWORD),\n        (\'NumberOfSymbols\', wintypes.DWORD),\n        (\'SizeOfOptionalHeader\', wintypes.WORD),\n        (\'Characteristics\', wintypes.WORD),\n    ]\n\n\nPIMAGE_FILE_HEADER = ctypes.POINTER(IMAGE_FILE_HEADER)\n\n\nclass IMAGE_NT_HEADERS(ctypes.Structure):\n    _fields_ = [\n        (\'Signature\', wintypes.DWORD),\n        (\'FileHeader\', IMAGE_FILE_HEADER),\n        (\'OptionalHeader\', IMAGE_OPTIONAL_HEADER),\n    ]\n\n\nPIMAGE_NT_HEADERS = ctypes.POINTER(IMAGE_NT_HEADERS)\n\n# Win32 API Function Prototypes\nVirtualAlloc = _kernel32.VirtualAlloc\nVirtualAlloc.restype = wintypes.LPVOID\nVirtualAlloc.argtypes = [wintypes.LPVOID, SIZE_T, wintypes.DWORD, wintypes.DWORD]\n\nVirtualFree = _kernel32.VirtualFree\nVirtualFree.restype = wintypes.BOOL\nVirtualFree.argtypes = [wintypes.LPVOID, SIZE_T, wintypes.DWORD]\n\nVirtualProtect = _kernel32.VirtualProtect\nVirtualProtect.restype = wintypes.BOOL\nVirtualProtect.argtypes = [wintypes.LPVOID, SIZE_T, wintypes.DWORD, PDWORD]\n\nHeapAlloc = _kernel32.HeapAlloc\nHeapAlloc.restype = wintypes.LPVOID\nHeapAlloc.argtypes = [wintypes.HANDLE, wintypes.DWORD, SIZE_T]\n\nGetProcessHeap = _kernel32.GetProcessHeap\nGetProcessHeap.restype = wintypes.HANDLE\nGetProcessHeap.argtypes = []\n\nHeapFree = _kernel32.HeapFree\nHeapFree.restype = wintypes.BOOL\nHeapFree.argtypes = [wintypes.HANDLE, wintypes.DWORD, wintypes.LPVOID]\n\nGetProcAddress = _kernel32.GetProcAddress\nGetProcAddress.restype = FARPROC\nGetProcAddress.argtypes = [wintypes.HMODULE, wintypes.LPCSTR]\n\nLoadLibraryA = _kernel32.LoadLibraryA\nLoadLibraryA.restype = wintypes.HMODULE\nLoadLibraryA.argtypes = [wintypes.LPCSTR]\n\nLoadLibraryW = _kernel32.LoadLibraryW\nLoadLibraryW.restype = wintypes.HMODULE\nLoadLibraryW.argtypes = [wintypes.LPCWSTR]\n\nFreeLibrary = _kernel32.FreeLibrary\nFreeLibrary.restype = wintypes.BOOL\nFreeLibrary.argtypes = [wintypes.HMODULE]\n\nIsBadReadPtr = _kernel32.IsBadReadPtr\nIsBadReadPtr.restype = wintypes.BOOL\nIsBadReadPtr.argtypes = [wintypes.LPCVOID, UINT_PTR]\n\nrealloc = _msvcrt.realloc\nrealloc.restype = ctypes.c_void_p\nrealloc.argtypes = [ctypes.c_void_p, ctypes.c_size_t]\n\n# Type declarations\nDllEntryProc = ctypes.WINFUNCTYPE(wintypes.BOOL, wintypes.HINSTANCE, wintypes.DWORD, wintypes.LPVOID)\nPDllEntryProc = ctypes.POINTER(DllEntryProc)\nTLSExecProc = ctypes.WINFUNCTYPE(wintypes.BOOL, wintypes.HINSTANCE, wintypes.DWORD, wintypes.LPVOID)\nPTLSExecProc = ctypes.POINTER(TLSExecProc)\nHMEMORYMODULE = wintypes.HMODULE\nExeEntryProc = ctypes.WINFUNCTYPE(wintypes.BOOL, wintypes.LPVOID)\nPExeEntryProc = ctypes.POINTER(ExeEntryProc)\n\n# Constants\nMEM_COMMIT = 0x00001000\nMEM_DECOMMIT = 0x4000\nMEM_RELEASE = 0x8000\nMEM_RESERVE = 0x00002000\nMEM_FREE = 0x10000\nMEM_MAPPED = 0x40000\nMEM_RESET = 0x00080000\nPAGE_NOACCESS = 0x01\nPAGE_READONLY = 0x02\nPAGE_READWRITE = 0x04\nPAGE_WRITECOPY = 0x08\nPAGE_EXECUTE = 0x10\nPAGE_EXECUTE_READ = 0x20\nPAGE_EXECUTE_READWRITE = 0x40\nPAGE_EXECUTE_WRITECOPY = 0x80\nPAGE_NOCACHE = 0x200\n\nProtectionFlags = (\n    (\n        (PAGE_NOACCESS, PAGE_WRITECOPY),\n        (PAGE_READONLY, PAGE_READWRITE),\n    ),\n    (\n        (PAGE_EXECUTE, PAGE_EXECUTE_WRITECOPY),\n        (PAGE_EXECUTE_READ, PAGE_EXECUTE_READWRITE),\n    ),\n)\n\nIMAGE_SCN_MEM_EXECUTE = 0x20000000\nIMAGE_SCN_MEM_READ = 0x40000000\nIMAGE_SCN_MEM_WRITE = 0x80000000\nIMAGE_SCN_MEM_DISCARDABLE = 0x02000000\nIMAGE_SCN_MEM_NOT_CACHED = 0x04000000\nIMAGE_SCN_CNT_INITIALIZED_DATA = 0x00000040\nIMAGE_SCN_CNT_UNINITIALIZED_DATA = 0x00000080\nIMAGE_DIRECTORY_ENTRY_EXPORT = 0\nIMAGE_DIRECTORY_ENTRY_IMPORT = 1\nIMAGE_DIRECTORY_ENTRY_RESOURCE = 2\nIMAGE_DIRECTORY_ENTRY_EXCEPTION = 3\nIMAGE_DIRECTORY_ENTRY_SECURITY = 4\nIMAGE_DIRECTORY_ENTRY_BASERELOC = 5\nIMAGE_DIRECTORY_ENTRY_DEBUG = 6\nIMAGE_DIRECTORY_ENTRY_ARCHITECTURE = 7\nIMAGE_DIRECTORY_ENTRY_GLOBALPTR = 8\nIMAGE_DIRECTORY_ENTRY_TLS = 9\nIMAGE_DIRECTORY_ENTRY_LOAD_CONFIG = 10\nIMAGE_DIRECTORY_ENTRY_BOUND_IMPORT = 11\nIMAGE_DIRECTORY_ENTRY_IAT = 12\nIMAGE_DIRECTORY_ENTRY_DELAY_IMPORT = 13\nIMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR = 14\nDLL_PROCESS_ATTACH = 1\nDLL_THREAD_ATTACH = 2\nDLL_THREAD_DETACH = 3\nDLL_PROCESS_DETACH = 0\nINVALID_HANDLE_VALUE = -1\nIMAGE_SIZEOF_BASE_RELOCATION = ctypes.sizeof(IMAGE_BASE_RELOCATION)\nIMAGE_REL_BASED_ABSOLUTE = 0\nIMAGE_REL_BASED_HIGH = 1\nIMAGE_REL_BASED_LOW = 2\nIMAGE_REL_BASED_HIGHLOW = 3\nIMAGE_REL_BASED_HIGHADJ = 4\nIMAGE_REL_BASED_MIPS_JMPADDR = 5\nIMAGE_REL_BASED_MIPS_JMPADDR16 = 9\nIMAGE_REL_BASED_IA64_IMM64 = 9\nIMAGE_REL_BASED_DIR64 = 10\n_IMAGE_ORDINAL_FLAG64 = 0x8000000000000000\n_IMAGE_ORDINAL_FLAG32 = 0x80000000\n_IMAGE_ORDINAL64 = lambda o: (o & 0xFFFF)\n_IMAGE_ORDINAL32 = lambda o: (o & 0xFFFF)\n_IMAGE_SNAP_BY_ORDINAL64 = lambda o: ((o & _IMAGE_ORDINAL_FLAG64) != 0)\n_IMAGE_SNAP_BY_ORDINAL32 = lambda o: ((o & _IMAGE_ORDINAL_FLAG32) != 0)\nIMAGE_ORDINAL = _IMAGE_ORDINAL64 if IS_X64 else _IMAGE_ORDINAL32\nIMAGE_SNAP_BY_ORDINAL = _IMAGE_SNAP_BY_ORDINAL64 if IS_X64 else _IMAGE_SNAP_BY_ORDINAL32\nIMAGE_ORDINAL_FLAG = _IMAGE_ORDINAL_FLAG64 if IS_X64 else _IMAGE_ORDINAL_FLAG32\nIMAGE_DOS_SIGNATURE = 0x5A4D  # MZ\nIMAGE_OS2_SIGNATURE = 0x454E  # NE\nIMAGE_OS2_SIGNATURE_LE = 0x454C  # LE\nIMAGE_VXD_SIGNATURE = 0x454C  # LE\nIMAGE_NT_SIGNATURE = 0x00004550  # PE00\n\n\nclass MEMORYMODULE(ctypes.Structure):\n    _fields_ = [\n        (\'headers\', PIMAGE_NT_HEADERS),\n        (\'codeBase\', ctypes.c_void_p),\n        (\'modules\', PHMODULE),\n        (\'numModules\', ctypes.c_int),\n        (\'initialized\', ctypes.c_int),\n    ]\n\n\nPMEMORYMODULE = ctypes.POINTER(MEMORYMODULE)\n\n\ndef as_unsigned_buffer(sz=None, indata=None):\n    if sz is None:\n        if indata is None:\n            raise Exception(\'Must specify initial data or a buffer size.\')\n        sz = len(indata)\n    rtype = (ctypes.c_ubyte * sz)\n    if indata is None:\n        return rtype\n    else:\n        tindata = type(indata)\n        if tindata is int:\n            return rtype.from_address(indata)\n        elif tindata in [ctypes.c_void_p, wintypes.DWORD, POINTER_TYPE] or (\n            hasattr(indata, \'value\') and type(indata.value) is int\n        ):\n            return rtype.from_address(indata.value)\n        else:\n            return rtype.from_address(ctypes.addressof(indata))\n\n\ndef create_unsigned_buffer(sz, indata):\n    res = as_unsigned_buffer(sz)()\n    for i, c in enumerate(indata):\n        if isinstance(c, str):\n            c = ord(c)\n        res[i] = c\n    return res\n\n\ndef get_procedure_address(handle, function_name):\n    _kernel32.GetProcAddress.argtypes = [ctypes.c_void_p, ctypes.c_char_p]\n    _kernel32.GetProcAddress.restype = ctypes.c_void_p\n    address = _kernel32.GetProcAddress(handle, function_name)\n    return address\n\n\nclass MemoryModule(PE):\n    _foffsets_ = {}\n\n    def __init__(self, name=None, data=None):\n        PE.__init__(self, name, data)\n        self.load_module()\n\n    def exec_pe(self):\n        codebase = self._codebase_addr\n        entry_addr = self.python_memory_module.contents.headers.contents.OptionalHeader.AddressOfEntryPoint\n        if entry_addr != 0:\n            entry_addr += codebase\n            if self.is_exe():\n                exe_entry = ExeEntryProc(entry_addr)\n                if not bool(exe_entry):\n                    self.free_library()\n                    raise WindowsError(\'exe has no entry point.\\n\')\n                try:\n                    success = exe_entry(entry_addr)\n                except Exception as e:\n                    print(e)\n            elif self.is_dll():\n                dll_entry = DllEntryProc(entry_addr)\n                if not bool(dll_entry):\n                    self.free_library()\n                    raise WindowsError(\'dll has no entry point.\\n\')\n                try:\n                    success = dll_entry(codebase, DLL_PROCESS_ATTACH, 0)\n                except Exception as e:\n                    print(e)\n            if not bool(success):\n                if self.is_dll():\n                    self.free_library()\n                    raise WindowsError(\'dll could not be loaded.\')\n                else:\n                    self.free_exe()\n                    raise WindowsError(\'exe could not be loaded\')\n            self.python_memory_module.contents.initialized = 1\n\n    def load_module(self):\n        if not self.is_exe() and not self.is_dll():\n            raise WindowsError(\'The specified module does not appear to be an exe nor a dll.\')\n        if self.PE_TYPE == 267 and IS_X64:\n            raise WindowsError(\n                \'The exe you attempted to load appears to be a 32-bit exe, but you are using a 64-bit version of Python.\'\n            )\n        elif self.PE_TYPE == 523 and not IS_X64:\n            raise WindowsError(\n                \'The exe you attempted to load appears to be a 64-bit exe, but you are using a 32-bit version of Python.\'\n            )\n        self._codebase_addr = VirtualAlloc(\n            self.OPTIONAL_HEADER.ImageBase,\n            self.OPTIONAL_HEADER.SizeOfImage,\n            MEM_RESERVE,\n            PAGE_READWRITE,\n        )\n        if not bool(self._codebase_addr):\n            self._codebase_addr = VirtualAlloc(\n                NULL,\n                self.OPTIONAL_HEADER.SizeOfImage,\n                MEM_RESERVE,\n                PAGE_READWRITE,\n            )\n            if not bool(self._codebase_addr):\n                raise WindowsError(\'Cannot reserve memory\')\n        codebase = self._codebase_addr\n        self.python_memory_module = ctypes.cast(\n            HeapAlloc(GetProcessHeap(), 0, ctypes.sizeof(MEMORYMODULE)), PMEMORYMODULE\n        )\n        self.python_memory_module.contents.codeBase = codebase\n        self.python_memory_module.contents.numModules = 0\n        self.python_memory_module.contents.modules = ctypes.cast(NULL, PHMODULE)\n        self.python_memory_module.contents.initialized = 0\n        # Committing memory.\n        VirtualAlloc(\n            codebase,\n            self.OPTIONAL_HEADER.SizeOfImage,\n            MEM_COMMIT,\n            PAGE_READWRITE,\n        )\n        self._headers_addr = VirtualAlloc(\n            codebase,\n            self.OPTIONAL_HEADER.SizeOfHeaders,\n            MEM_COMMIT,\n            PAGE_READWRITE,\n        )\n        if not bool(self._headers_addr):\n            raise WindowsError(\'Could not commit memory for PE Headers!\')\n        sz_headers = self.DOS_HEADER.e_lfanew + self.OPTIONAL_HEADER.SizeOfHeaders\n        tmp_headers = create_unsigned_buffer(sz_headers, self.__data__[:sz_headers])\n        if not ctypes.memmove(self._headers_addr, ctypes.cast(tmp_headers, ctypes.c_void_p), sz_headers):\n            raise RuntimeError(\'ctypes.memmove failed\')\n        del tmp_headers\n        self._headers_addr += self.DOS_HEADER.e_lfanew\n        self.python_memory_module.contents.headers = ctypes.cast(self._headers_addr, PIMAGE_NT_HEADERS)\n        self.python_memory_module.contents.headers.contents.OptionalHeader.ImageBase = POINTER_TYPE(\n            self._codebase_addr\n        )\n        self.copy_sections()\n        location_delta = codebase - self.OPTIONAL_HEADER.ImageBase\n        if location_delta != 0:\n            self.perform_base_relocations(location_delta)\n        self.build_import_table()\n        self.finalize_sections()\n        self.execute_tls()\n        my_thread = threading.Thread(target=self.exec_pe)\n        my_thread.start()\n\n    def image_first_section(self):\n        return self._headers_addr + IMAGE_NT_HEADERS.OptionalHeader.offset + self.FILE_HEADER.SizeOfOptionalHeader\n\n    def copy_sections(self):\n        codebase = self._codebase_addr\n        section_addr = self.image_first_section()\n        num_sections = self.python_memory_module.contents.headers.contents.FileHeader.NumberOfSections\n        for i in range(0, num_sections):\n            if self.sections[i].SizeOfRawData == 0:\n                size = self.OPTIONAL_HEADER.SectionAlignment\n                if size > 0:\n                    dest_base_addr = codebase + self.sections[i].VirtualAddress\n                    dest = VirtualAlloc(dest_base_addr, size, MEM_COMMIT, PAGE_READWRITE)\n                    self.sections[i].Misc_PhysicalAddress = dest\n                    ctypes.memset(dest, 0, size)\n                continue\n            size = self.sections[i].SizeOfRawData\n            dest = VirtualAlloc(\n                codebase + self.sections[i].VirtualAddress, size, MEM_COMMIT, PAGE_READWRITE\n            )\n            if dest <= 0:\n                raise WindowsError(\n                    \'Error copying section no. %s to address: 0x%x\',\n                    self.sections[i].Name.decode(\'utf-8\'),\n                    dest,\n                )\n            self.sections[i].Misc_PhysicalAddress = dest\n            tmp_data = create_unsigned_buffer(\n                size, self.__data__[self.sections[i].PointerToRawData : (self.sections[i].PointerToRawData + size)]\n            )\n            if not ctypes.memmove(dest, tmp_data, size):\n                raise RuntimeError(\'ctypes.memmove failed\')\n            del tmp_data\n            i += 1\n\n    def execute_tls(self):\n        codebase = self._codebase_addr\n        directory = self.OPTIONAL_HEADER.DATA_DIRECTORY[IMAGE_DIRECTORY_ENTRY_TLS]\n        if directory.VirtualAddress <= 0:\n            return True\n        tls_addr = codebase + directory.VirtualAddress\n        tls = IMAGE_TLS_DIRECTORY.from_address(tls_addr)\n        callback = IMAGE_TLS_CALLBACK.from_address(tls.AddressOfCallBacks)\n        callback_addr = tls.AddressOfCallBacks\n        while callback:\n            tls_exec = TLSExecProc(callback.value)\n            tls_res = tls_exec(ctypes.cast(codebase, wintypes.LPVOID), DLL_PROCESS_ATTACH, 0)\n            if not bool(tls_res):\n                raise WindowsError(\'TLS could not be executed.\')\n            else:\n                callback_addr += ctypes.sizeof(ctypes.c_ulonglong)\n                callback = IMAGE_TLS_CALLBACK.from_address(callback_addr)\n\n    def finalize_sections(self):\n        section_addr = self.image_first_section()\n        num_sections = self.python_memory_module.contents.headers.contents.FileHeader.NumberOfSections\n        image_offset = (\n            POINTER_TYPE(self.python_memory_module.contents.headers.contents.OptionalHeader.ImageBase & 0xFFFFFFFF00000000)\n            if IS_X64\n            else POINTER_TYPE(0)\n        )\n        check_characteristic = lambda sect, flag: 1 if (sect.contents.Characteristics & flag) != 0 else 0\n        get_phys_addr = lambda sect: section.contents.PhysicalAddress | image_offset.value\n        for i in range(0, num_sections):\n            section = ctypes.cast(section_addr, PIMAGE_SECTION_HEADER)\n            size = section.contents.SizeOfRawData\n            if size == 0:\n                if check_characteristic(section, IMAGE_SCN_CNT_INITIALIZED_DATA):\n                    size = self.python_memory_module.contents.headers.contents.OptionalHeader.SizeOfInitializedData\n                elif check_characteristic(section, IMAGE_SCN_CNT_UNINITIALIZED_DATA):\n                    size = self.python_memory_module.contents.headers.contents.OptionalHeader.SizeOfUninitializedData\n                    continue\n            if size == 0:\n                continue\n            old_protect = wintypes.DWORD(0)\n            executable = check_characteristic(section, IMAGE_SCN_MEM_EXECUTE)\n            readable = check_characteristic(section, IMAGE_SCN_MEM_READ)\n            writeable = check_characteristic(section, IMAGE_SCN_MEM_WRITE)\n            if check_characteristic(section, IMAGE_SCN_MEM_DISCARDABLE):\n                addr = self.sections[i].Misc_PhysicalAddress\n                VirtualFree(addr, section.contents.SizeOfRawData, MEM_DECOMMIT)\n                continue\n            protect = ProtectionFlags[executable][readable][writeable]\n            if check_characteristic(section, IMAGE_SCN_MEM_NOT_CACHED):\n                protect |= PAGE_NOCACHE\n            size = section.contents.SizeOfRawData\n            if size == 0:\n                if check_characteristic(section, IMAGE_SCN_CNT_INITIALIZED_DATA):\n                    size = self.python_memory_module.contents.headers.contents.OptionalHeader.SizeOfInitializedData\n                elif check_characteristic(section, IMAGE_SCN_CNT_UNINITIALIZED_DATA):\n                    size = self.python_memory_module.contents.headers.contents.OptionalHeader.SizeOfUninitializedData\n            if size > 0:\n                addr = self.sections[i].Misc_PhysicalAddress\n                if VirtualProtect(addr, size, protect, ctypes.byref(old_protect)) == 0:\n                    raise WindowsError(\'Error protecting memory page\')\n            section_addr += ctypes.sizeof(IMAGE_SECTION_HEADER)\n            i += 1\n\n    def perform_base_relocations(self, delta):\n        codebase_addr = self._codebase_addr\n        directory = self.OPTIONAL_HEADER.DATA_DIRECTORY[IMAGE_DIRECTORY_ENTRY_BASERELOC]\n        if directory.Size <= 0:\n            return\n        reloc_addr = codebase_addr + directory.VirtualAddress\n        relocation = IMAGE_BASE_RELOCATION.from_address(reloc_addr)\n        max_reloc = lambda r: (relocation.SizeOfBlock - IMAGE_SIZEOF_BASE_RELOCATION) // 2\n        while relocation.VirtualAddress > 0:\n            i = 0\n            dest = codebase_addr + relocation.VirtualAddress\n            rel_info_addr = reloc_addr + IMAGE_SIZEOF_BASE_RELOCATION\n            while i < max_reloc(reloc_addr):\n                rel_info = ctypes.c_ushort.from_address(rel_info_addr)\n                type = rel_info.value >> 12\n                offset = rel_info.value & 0xFFF\n                if type == IMAGE_REL_BASED_HIGHLOW or (type == IMAGE_REL_BASED_DIR64 and IS_X64):\n                    patch_addr_hl = ctypes.cast(dest + offset, LP_POINTER_TYPE)\n                    patch_addr_hl.contents.value += delta\n                else:\n                    break\n                rel_info_addr += 2\n                i += 1\n            reloc_addr += relocation.SizeOfBlock\n            relocation = IMAGE_BASE_RELOCATION.from_address(reloc_addr)\n\n    def build_import_table(self, dlopen=LoadLibraryW):\n        codebase = self._codebase_addr\n        directory = self.OPTIONAL_HEADER.DATA_DIRECTORY[IMAGE_DIRECTORY_ENTRY_IMPORT]\n        if directory.Size <= 0:\n            return\n        import_desc_addr = codebase + directory.VirtualAddress\n        i = 0\n        for i in range(0, len(self.DIRECTORY_ENTRY_IMPORT)):\n            import_desc = directory.VirtualAddress\n            entry_struct = self.DIRECTORY_ENTRY_IMPORT[i].struct\n            entry_imports = self.DIRECTORY_ENTRY_IMPORT[i].imports\n            dll = self.DIRECTORY_ENTRY_IMPORT[i].dll.decode(\'utf-8\')\n            if not bool(dll):\n                hmod = dll\n            else:\n                hmod = dlopen(dll)\n                if not bool(hmod):\n                    raise WindowsError(\'Failed to load library, %s\' % dll)\n                result_realloc = realloc(\n                    self.python_memory_module.contents.modules,\n                    (self.python_memory_module.contents.modules._b_base_.numModules + 1)\n                    * ctypes.sizeof(wintypes.HMODULE),\n                )\n                if not bool(result_realloc):\n                    raise WindowsError(\'Failed to allocate additional room for our new import.\')\n                self.python_memory_module.contents.modules = ctypes.cast(\n                    result_realloc, type(self.python_memory_module.contents.modules)\n                )\n                self.python_memory_module.contents.modules[\n                    self.python_memory_module.contents.modules._b_base_.numModules\n                ] = hmod\n                self.python_memory_module.contents.modules._b_base_.numModules += 1\n            thunk_ref_addr = func_ref_addr = codebase + entry_struct.FirstThunk\n            if entry_struct.OriginalFirstThunk > 0:\n                thunk_ref_addr = codebase + entry_struct.OriginalFirstThunk\n            for j in range(0, len(entry_imports)):\n                func_ref = ctypes.cast(func_ref_addr, PFARPROC)\n                if entry_imports[j].import_by_ordinal is True:\n                    import_ordinal = (\n                        entry_imports[j].ordinal.decode(\'utf-8\')\n                        if hasattr(entry_imports[j].ordinal, \'decode\')\n                        else entry_imports[j].ordinal\n                    )\n                    func_ref.contents = GetProcAddress(hmod, ctypes.cast(import_ordinal, wintypes.LPCSTR))\n                    address = func_ref.contents\n                else:\n                    import_name = entry_imports[j].name.decode(\'utf-8\')\n                    address = get_procedure_address(hmod, import_name.encode())\n                    if not ctypes.memmove(\n                        func_ref_addr, address.to_bytes(ctypes.sizeof(LONG_PTR), \'little\'), ctypes.sizeof(LONG_PTR)\n                    ):\n                        raise WindowsError(\'ctypes.memmove failed\')\n                if not bool(address):\n                    raise WindowsError(\'Could not locate function for thunkref %s\', import_name)\n                func_ref_addr += ctypes.sizeof(PFARPROC)\n                j += 1\n            i += 1\n\n    def free_library(self):\n        if not bool(self.python_memory_module):\n            return\n        pmodule = ctypes.pointer(self.python_memory_module)\n        if self.python_memory_module.contents.initialized != 0:\n            dll_entry = DllEntryProc(\n                self.python_memory_module.contents.codeBase\n                + self.python_memory_module.contents.headers.contents.OptionalHeader.AddressOfEntryPoint\n            )\n            dll_entry(\n                ctypes.cast(self.python_memory_module.contents.codeBase, wintypes.HINSTANCE),\n                DLL_PROCESS_DETACH,\n                0,\n            )\n            pmodule.contents.initialized = 0\n        if bool(self.python_memory_module.contents.modules) and self.python_memory_module.contents.numModules > 0:\n            for i in range(1, self.python_memory_module.contents.numModules):\n                if self.python_memory_module.contents.modules[i] != wintypes.HANDLE(INVALID_HANDLE_VALUE):\n                    FreeLibrary(self.python_memory_module.contents.modules[i])\n        if bool(self._codebase_addr):\n            VirtualFree(self._codebase_addr, 0, MEM_RELEASE)\n        HeapFree(GetProcessHeap(), 0, self.python_memory_module)\n        self.close()\n\n    def free_exe(self):\n        if not bool(self.python_memory_module):\n            return\n        pmodule = ctypes.pointer(self.python_memory_module)\n        if bool(self._codebase_addr):\n            VirtualFree(self._codebase_addr, 0, MEM_RELEASE)\n        HeapFree(GetProcessHeap(), 0, self.python_memory_module)\n        self.close()\n\n    def _procedure_address_by_ordinal(self, idx):\n        codebase = self._codebase_addr\n        if idx == -1:\n            raise WindowsError(\'Could not find the function specified\')\n        elif idx > self._exports_.NumberOfFunctions:\n            raise WindowsError(\'Ordinal number higher than our actual count.\')\n        func_offset = wintypes.DWORD.from_address(codebase + self._exports_.AddressOfFunctions + (idx * 4))\n        return func_offset.value\n\n    def _procedure_address_by_name(self, name):\n        codebase = self._codebase_addr\n        exports = self._exports_\n        if exports.NumberOfNames == 0:\n            raise WindowsError("DLL doesn\'t export anything.")\n        ordinal = -1\n        name = name.lower()\n        name_ref_addr = codebase + exports.AddressOfNames\n        ordinal_addr = codebase + exports.AddressOfNamesOrdinals\n        i = 0\n        while i < exports.NumberOfNames:\n            name_ref = wintypes.DWORD.from_address(name_ref_addr)\n            func_name = ctypes.string_at(codebase + name_ref.value).lower()\n            if func_name.decode() == name:\n                ordinal = wintypes.WORD.from_address(ordinal_addr).value\n            i += 1\n            name_ref_addr += ctypes.sizeof(wintypes.DWORD)\n            ordinal_addr += ctypes.sizeof(wintypes.WORD)\n        return self._procedure_address_by_ordinal(ordinal)\n\n    def get_procedure_address(self, name_or_ordinal):\n        codebase = self._codebase_addr\n        if not hasattr(self, \'_exports_\'):\n            directory = self.OPTIONAL_HEADER.DATA_DIRECTORY[IMAGE_DIRECTORY_ENTRY_EXPORT]\n            if directory.Size <= 0:\n                raise WindowsError(\'No export table found.\')\n            self._exports_ = IMAGE_EXPORT_DIRECTORY.from_address(codebase + directory.VirtualAddress)\n            if self._exports_.NumberOfFunctions == 0:\n                raise WindowsError("DLL doesn\'t export anything.")\n        if isinstance(name_or_ordinal, str):\n            procaddr_func = self._procedure_address_by_name\n        elif isinstance(name_or_ordinal, int):\n            procaddr_func = self._procedure_address_by_ordinal\n        else:\n            raise TypeError("Don\'t know what to do with name/ordinal of type: %s!" % type(name_or_ordinal))\n        if name_or_ordinal not in self._foffsets_:\n            self._foffsets_[name_or_ordinal] = procaddr_func(name_or_ordinal)\n        return FARPROC(codebase + self._foffsets_[name_or_ordinal])\n')
